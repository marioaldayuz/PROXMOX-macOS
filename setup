#!/bin/bash
#
# HACKINTOSHSTER-PROXMOX: Modern macOS VM Deployment System
# Automated deployment of macOS 15+ (Sequoia/Tahoe) virtual machines on Proxmox VE
# Optimized for modern macOS with VirtIO drivers, Skylake-Client-v4 CPU emulation,
# OpenCore bootloader, and comprehensive hardware compatibility.
#
# Author: Mario Aldayuz (thenotoriousllama)
# Website: https://aldayuz.com
#
# COPYRIGHT - 2024-2026
#
# Supports: macOS Sequoia (15) and macOS Tahoe (26)
# Platform: Proxmox VE 7.x, 8.x, 9.x (Intel and AMD processors)
# Features: VirtIO networking/storage, automated recovery image creation,
#           network bridge provisioning, SMBIOS customization, DHCP server
#
################################################################################################################################################################################################

# Terminate script execution immediately if any command returns non-zero exit status
set -e

# Global configuration constants defining paths, versions, and resource allocation defaults
SCRIPT_DIR="/root/PROXMOX-macOS"              # Primary working directory for all script operations
LOGDIR="${SCRIPT_DIR}/logs"                         # Centralized location for all operation logs
MAIN_LOG="${LOGDIR}/main.log"                       # Master log file capturing all script activities
TMPDIR="${SCRIPT_DIR}/tmp"                          # Temporary storage for ISO building and loop mounts
HACKOCVERSION="2025.11.23"                          # Current release version of this automation script
OCVERSION="1.0.6"                                   # OpenCore bootloader version bundled with ISOs
DEFAULT_VM_PREFIX="macOS-"                          # Naming convention prefix for newly created VMs
BASE_RAM_SIZE=4096                                  # Minimum RAM allocation in MiB (4GB baseline)
RAM_PER_CORE=1024                                   # Additional RAM per CPU core in MiB (1GB per core for modern macOS)
MAX_CORES=16                                        # Maximum CPU cores allowed per VM to prevent overallocation
DHCP_CONF_DIR="/etc/dhcp/dhcpd.d"                  # Directory containing per-bridge DHCP configuration files
NETWORK_INTERFACES_FILE="/etc/network/interfaces"  # Debian network configuration file for bridge definitions
DHCP_USER="dhcpd"                                   # System user/group name for ISC DHCP server daemon

# Associative array mapping menu options to macOS version metadata
# Format: [option_number]="Display_Name|Version|Board_ID|Model_ID|Recovery_Size|Disk_Interface"
# Only supporting macOS 15+ (Sequoia and Tahoe)
declare -A MACOS_CONFIG=(
  ["1"]="Sequoia|15|Mac-7BA5B2D9E42DDD94|00000000000000000|1450M|virtio0"
  ["2"]="Tahoe|26|Mac-7BA5B2D9E42DDD94|00000000000000000|1450M|virtio0"
)

# Parse command-line arguments for non-interactive mode
INTERACTIVE_MODE=true
if [[ $# -gt 0 ]]; then
  INTERACTIVE_MODE=false
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      --version)
        CLI_VERSION="$2"
        shift 2
        ;;
      --vmid)
        CLI_VM_ID="$2"
        shift 2
        ;;
      --name)
        CLI_VM_NAME="$2"
        shift 2
        ;;
      --disk)
        CLI_DISK_SIZE="$2"
        shift 2
        ;;
      --storage)
        CLI_STORAGE="$2"
        shift 2
        ;;
      --bridge)
        CLI_BRIDGE="$2"
        shift 2
        ;;
      --cores)
        CLI_CORES="$2"
        shift 2
        ;;
      --ram)
        CLI_RAM="$2"
        shift 2
        ;;
      --download-recovery)
        CLI_DOWNLOAD_RECOVERY="yes"
        shift
        ;;
      --help|-h)
        echo "Usage: setup [OPTIONS]"
        echo ""
        echo "Interactive mode (no arguments): Launch menu-driven interface"
        echo ""
        echo "Non-interactive mode options:"
        echo "  --version <sequoia|tahoe>    macOS version to install"
        echo "  --vmid <id>                  VM ID (default: next available)"
        echo "  --name <name>                VM name (default: macOS-SEQUOIA or macOS-TAHOE)"
        echo "  --disk <size>                Disk size in GB (default: 80)"
        echo "  --storage <storage>          Proxmox storage name (default: auto-detect)"
        echo "  --bridge <bridge>            Network bridge (default: vmbr0)"
        echo "  --cores <count>              CPU cores - power of 2 (default: 4)"
        echo "  --ram <size>                 RAM in MiB (default: auto-calculate)"
        echo "  --download-recovery          Download recovery image from Apple"
        echo ""
        echo "Example:"
        echo "  mac --version sequoia --vmid 100 --name MyMac --disk 120 --cores 8"
        exit 0
        ;;
      *)
        echo "Unknown option: $1"
        echo "Use --help for usage information"
        exit 1
        ;;
    esac
  done
fi

# Unified output function that simultaneously displays messages to console and appends to log files
# Ensures all user-facing messages are captured with timestamps for troubleshooting
# Parameters:
#   $1 - The message text to display and log
#   $2 - Optional path to a specific log file for operation-specific logging
display_and_log() {
  local message="$1"
  local specific_logfile="$2"
  echo "$message"
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $message" >> "$MAIN_LOG"
  if [[ -n "$specific_logfile" ]]; then
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $message" >> "$specific_logfile"
  fi
}

# Automatic resource cleanup handler that executes on script exit (success or failure)
# Safely unmounts any active loop devices and removes temporary files to prevent resource leaks
# Registered via trap to ensure cleanup occurs even during abnormal termination
cleanup() {
  local logfile="${LOGDIR}/cleanup.log"
  # Unmount Apple recovery image mount point if currently mounted
  if mountpoint -q /mnt/APPLE 2>/dev/null; then
    umount /mnt/APPLE >>"$logfile" 2>&1 || display_and_log "Failed to unmount /mnt/APPLE" "$logfile"
    rmdir /mnt/APPLE 2>/dev/null
  fi
  # Unmount OpenCore ISO mount point if currently mounted
  if mountpoint -q /mnt/opencore 2>/dev/null; then
    umount /mnt/opencore >>"$logfile" 2>&1 || display_and_log "Failed to unmount /mnt/opencore" "$logfile"
    rmdir /mnt/opencore 2>/dev/null
  fi
  # Detach any loop devices associated with temporary directory files
  losetup -a | grep -q "$TMPDIR" && losetup -d $(losetup -j "$TMPDIR"/* | awk -F: '{print $1}') >>"$logfile" 2>&1
  # Purge all temporary files while protecting against accidental root deletion
  rm -rf "${TMPDIR:?}"/* 2>/dev/null
}
# Register cleanup function to execute automatically when script exits
trap cleanup EXIT

# Mathematical validator to determine if a given integer is a power of two
# Uses bitwise AND operation: powers of 2 have exactly one bit set, so (n & (n-1)) equals zero
# Required for CPU core allocation since macOS performs better with power-of-2 core counts
# Parameters: $1 - Integer to validate
# Returns: 0 (success) if power of 2, 1 (failure) otherwise
is_power_of_2() {
  local n=$1
  ((n > 0 && (n & (n - 1)) == 0))
}

# Calculates the smallest power of two that is greater than or equal to input value
# Iteratively doubles starting from 1 until reaching or exceeding the target number
# Used to round up user-specified CPU cores to the nearest valid power-of-2 value
# Parameters: $1 - Target integer value
# Output: Next power of 2 (e.g., 5→8, 9→16)
next_power_of_2() {
  local n=$1
  local p=1
  while ((p < n)); do
    p=$((p * 2))
  done
  echo $p
}

# Critical error handler that logs failure message and terminates script execution
# Provides consistent error reporting across all functions with proper log file routing
# Parameters:
#   $1 - Human-readable error message describing the failure
#   $2 - Path to specific log file for detailed error context
# Always exits with status code 1 to indicate failure to calling processes
log_and_exit() {
  local message=$1
  local logfile=$2
  display_and_log "$message" "$logfile"
  exit 1
}

# Input validator for VM naming conventions enforced by Proxmox
# Ensures names start/end with alphanumeric characters and contain only safe characters
# Prevents whitespace which can cause issues in shell scripts and Proxmox API calls
# Parameters: $1 - Proposed VM name string
# Returns: 0 if valid, 1 if invalid (contains spaces or invalid characters)
validate_vm_name() {
  local vm_name=$1
  [[ "$vm_name" =~ ^[a-zA-Z0-9][a-zA-Z0-9_.-]*[a-zA-Z0-9]$ && ! "$vm_name" =~ [[:space:]] ]]
}

# Semantic version comparison utility for determining if v1 >= v2
# Splits version strings on dots and compares each numeric component left-to-right
# Handles versions with different segment counts by treating missing parts as zero
# Used to check QEMU version compatibility for applying conditional device arguments
# Parameters:
#   $1 - First version string (e.g., "6.2.0")
#   $2 - Second version string (e.g., "6.1")
# Returns: 0 if v1 >= v2, 1 if v1 < v2
version_compare() {
  local v1=$1 v2=$2
  local IFS='.'
  local v1_parts=($v1) v2_parts=($v2)
  local max_len=$(( ${#v1_parts[@]} > ${#v2_parts[@]} ? ${#v1_parts[@]} : ${#v2_parts[@]} ))

  for ((i=0; i<max_len; i++)); do
    local v1_part=${v1_parts[i]:-0}
    local v2_part=${v2_parts[i]:-0}
    if (( v1_part > v2_part )); then
      return 0
    elif (( v1_part < v2_part )); then
      return 1
    fi
  done
  return 0
}

# Discovers all Proxmox storage volumes capable of hosting VM disk images
# Queries pvesm for active storages with 'images' content type and calculates available space
# Automatically selects the storage with most free space as the default recommendation
# Output format: One line per storage as "name|bytes|GB", followed by default storage name
# Returns: Multi-line output suitable for parsing by calling functions
get_available_storages() {
  local logfile="${LOGDIR}/storage-detection.log"
  local storages=()
  local max_space=0
  local default_storage=""

  local storage_list
  storage_list=$(pvesm status --content images 2>>"$logfile") || log_and_exit "Failed to retrieve storage list" "$logfile"
  while IFS= read -r line; do
    # Skip header line from pvesm output
    [[ "$line" =~ ^Name.* ]] && continue
    read -r storage_name type status total used avail percent <<< "$line"
    # Filter out inactive storages and those with zero or invalid available space
    [[ "$status" != "active" || ! "$avail" =~ ^[0-9]+$ || "$avail" -eq 0 ]] && continue
    # Convert available space from KB to GB with two decimal precision
    local avail_space_gb=$(echo "scale=2; $avail / 1024 / 1024" | bc 2>/dev/null)
    storages+=("$storage_name|$avail|$avail_space_gb")
    # Track storage with maximum available space for default selection
    if [[ $(echo "$avail > $max_space" | bc -l) -eq 1 ]]; then
      max_space=$avail
      default_storage="$storage_name"
    fi
  done <<< "$storage_list"

  [[ ${#storages[@]} -eq 0 || -z "$default_storage" ]] && log_and_exit "No active storages found" "$logfile"
  for storage in "${storages[@]}"; do echo "$storage"; done
  echo "$default_storage"
}

# Enumerates Proxmox storage locations configured to store ISO image files
# Similar to get_available_storages but filters for 'iso' content type instead of 'images'
# Used during initialization to determine where OpenCore and recovery ISOs will be stored
# Output format: One line per storage as "name|bytes|GB", followed by default storage name
# Returns: Multi-line output with storage candidates and automatic default selection
get_available_iso_storages() {
  local logfile="${LOGDIR}/iso-storage-detection.log"
  local storages=()
  local max_space=0
  local default_storage=""

  local storage_list
  storage_list=$(pvesm status --content iso 2>>"$logfile") || log_and_exit "Failed to retrieve ISO storage list" "$logfile"
  while IFS= read -r line; do
    # Skip header line from pvesm status output
    [[ "$line" =~ ^Name.* ]] && continue
    read -r storage_name type status total used avail percent <<< "$line"
    # Only consider active storages with valid available space
    [[ "$status" != "active" || ! "$avail" =~ ^[0-9]+$ || "$avail" -eq 0 ]] && continue
    # Convert KB to human-readable GB format
    local avail_space_gb=$(echo "scale=2; $avail / 1024 / 1024" | bc 2>/dev/null)
    storages+=("$storage_name|$avail|$avail_space_gb")
    # Automatically prefer the storage with most available capacity
    if [[ $(echo "$avail > $max_space" | bc -l) -eq 1 ]]; then
      max_space=$avail
      default_storage="$storage_name"
    fi
  done <<< "$storage_list"

  [[ ${#storages[@]} -eq 0 || -z "$default_storage" ]] && log_and_exit "No active ISO storages found" "$logfile"
  for storage in "${storages[@]}"; do echo "$storage"; done
  echo "$default_storage"
}

# Dependency installer for jq JSON processor required for parsing Proxmox API responses
# Checks if jq is already available in PATH before attempting installation
# Used extensively for extracting storage paths and parsing SMBIOS JSON files
# Automatically updates apt cache if installation is needed
ensure_jq_dependency() {
  local logfile="${LOGDIR}/jq-dependency.log"
  if ! command -v jq >/dev/null 2>&1; then
    display_and_log "Installing jq..." "$logfile"
    apt-get update >>"$logfile" 2>&1 || log_and_exit "Failed to update apt" "$logfile"
    apt-get install -y jq >>"$logfile" 2>&1 || log_and_exit "Failed to install jq" "$logfile"
  fi
}

# Dependency installer for xmlstarlet XML manipulation toolkit
# Required for reading and modifying OpenCore config.plist files programmatically
# Enables XPath-based queries and updates to nested plist dictionary structures
# Only installs if not already present in the system
ensure_xmlstarlet_dependency() {
  local logfile="${LOGDIR}/xmlstarlet-dependency.log"
  if ! command -v xmlstarlet >/dev/null 2>&1; then
    display_and_log "Installing xmlstarlet..." "$logfile"
    apt-get update >>"$logfile" 2>&1 || log_and_exit "Failed to update apt" "$logfile"
    apt-get install -y xmlstarlet >>"$logfile" 2>&1 || log_and_exit "Failed to install xmlstarlet" "$logfile"
  fi
}

# Dependency installer for binary encoding utilities needed for ROM address manipulation
# base64: Encodes/decodes binary data for plist storage compatibility
# xxd: Converts between hexadecimal and binary representations
# These tools are essential for properly formatting MAC addresses in OpenCore config
# Falls back gracefully if installation fails, allowing base64-only operation
ensure_base64_xxd_dependency() {
  local logfile="${LOGDIR}/base64-xxd-dependency.log"
  if ! command -v base64 >/dev/null || ! command -v xxd >/dev/null; then
    display_and_log "Installing base64 and xxd..." "$logfile"
    apt-get update >>"$logfile" 2>&1 || log_and_exit "Failed to update apt" "$logfile"
    apt-get install -y coreutils xxd vim-common >>"$logfile" 2>&1 || display_and_log "Failed to install base64 and xxd. Editing ROM in base64 format." "$logfile"
  fi
}

# Interactive ISO storage selector that determines where bootloader and recovery images reside
# Presents available ISO-capable storages to user or auto-selects if only one exists
# Queries Proxmox API to resolve storage name to actual filesystem path
# Sets global ISODIR variable pointing to the template/iso subdirectory
# This function must run early in script execution as ISODIR is used throughout
set_isodir() {
  local logfile="${LOGDIR}/iso-storage-detection.log"
  ensure_jq_dependency
  local storage_output=$(get_available_iso_storages) || { display_and_log "Failed to retrieve ISO storages"; read -n 1 -s; return 1; }
  local storages=() default_storage=""
  # Parse multi-line output separating storage entries from default marker
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    [[ -z "$default_storage" && ! "$line" =~ \| ]] && default_storage="$line" || storages+=("$line")
  done <<< "$storage_output"

  if ((${#storages[@]} == 0)); then
    log_and_exit "No ISO storages found" "$logfile"
  fi

  # Skip interactive prompt if only one storage is available
  if ((${#storages[@]} == 1)); then
    storage_iso="${storages[0]%%|*}"
    display_and_log "Using ISO storage: $storage_iso" "$logfile"
  else
    # Present menu of available storages with capacity information
    while true; do
      display_and_log "Available ISO storages:" "$logfile"
      for s in "${storages[@]}"; do
        storage_name="${s%%|*}"
        avail_space="${s##*|}"
        display_and_log "  - $storage_name ($avail_space GB)" "$logfile"
      done
      read -rp "ISO Storage [${default_storage}]: " storage_iso
      storage_iso=${storage_iso:-$default_storage}
      # Validate user input against available storage names
      local valid=false
      for s in "${storages[@]}"; do
        if [[ "$storage_iso" == "${s%%|*}" ]]; then
          valid=true
          break
        fi
      done
      if $valid; then
        display_and_log "Selected ISO storage: $storage_iso" "$logfile"
        break
      else
        display_and_log "Invalid ISO storage. Please try again." "$logfile"
      fi
    done
  fi

  # Resolve storage name to filesystem path via Proxmox API
  local storage_iso_path
  storage_iso_path=$(pvesh get /storage/"${storage_iso}" --output-format json | jq -r '.path') || log_and_exit "Failed to retrieve path for storage $storage_iso" "$logfile"
  [[ -z "$storage_iso_path" ]] && log_and_exit "Storage path for $storage_iso is empty" "$logfile"
  # Construct standard Proxmox ISO directory path
  ISODIR="${storage_iso_path}/template/iso/"
  mkdir -p "$ISODIR" || log_and_exit "Failed to create ISODIR: $ISODIR" "$logfile"
  display_and_log "ISODIR set to: $ISODIR" "$logfile"
}

# Network bridge discovery function that scans system for configured virtual bridges
# Parses /etc/network/interfaces for vmbr* definitions and validates they exist in kernel
# Extracts IP addresses assigned to each bridge for display purposes
# Output format: One line per bridge as "vmbr#|IP_address", followed by default bridge name
# Returns: Multi-line output with bridge candidates, defaults to vmbr0 if none found
get_available_bridges() {
  local bridges=()
  local default_bridge="vmbr0"

  # Extract all bridge interface definitions from network config
  local bridge_lines=$(grep -E '^iface vmbr[0-9]+' "$NETWORK_INTERFACES_FILE")
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    if [[ "$line" =~ ^iface\ (vmbr[0-9]+) ]]; then
      local bridge_name="${BASH_REMATCH[1]}"
      # Verify bridge actually exists in kernel networking stack
      [[ ! -d "/sys/class/net/$bridge_name" ]] && continue
      # Extract IP address from bridge configuration, stripping CIDR notation
      local address=$(awk "/^iface $bridge_name/{p=1} p&&/^[[:space:]]*address/{print \$2; exit}" "$NETWORK_INTERFACES_FILE" | sed 's|/.*||' | tr -d '\r')
      # Validate extracted address is a proper IPv4 format
      if [[ -n "$address" && "$address" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        bridges+=("$bridge_name|$address")
      else
        bridges+=("$bridge_name|unknown")
      fi
    fi
  done <<< "$bridge_lines"

  # Fallback to vmbr0 if no bridges were discovered
  [[ ${#bridges[@]} -eq 0 ]] && bridges+=("$default_bridge|unknown")
  printf '%s\n' "${bridges[@]}"
  echo "$default_bridge"
}

# Bootstrap function that creates essential directory structure for script operations
# Establishes log directory for operation tracking and temp directory for ISO manipulation
# Must execute before any logging or file operations occur
# Creates main log file to prevent append errors during initial operations
init_dirs() {
  mkdir -p "$LOGDIR" "$TMPDIR" || log_and_exit "Failed to create directories" "${LOGDIR}/init-dirs.log"
  touch "$MAIN_LOG"  # Initialize main log file to prevent "file not found" errors
}

# Proxmox VE version compatibility validator
# Ensures host is running a supported major version (7.x, 8.x, or 9.x)
# Proxmox 9 support is marked as preliminary with explicit user warning
# Exits script if running on unsupported versions to prevent configuration issues
check_proxmox_version() {
  local log_file="${LOGDIR}/proxmox-version.log"

  # Extract major version number from pveversion output
  local version=$(pveversion | grep -oE "pve-manager/[0-9.]+")
  if [[ "$version" != pve-manager/[7-9].* ]]; then
    log_and_exit "Unsupported Proxmox version. Use 7.x, 8.x, or 9.x" "$log_file"
  fi

  # Display cautionary message for Proxmox 9 early adopters
  if [[ "$version" == pve-manager/9.* ]]; then
    display_and_log "It is in Apple's DNA that technology alone is not enough—it's technology married with liberal arts, married with the humanities, that yields us the results that make our hearts sing." "$log_file"
    sleep 5
  fi
}

# Hardware platform detection for CPU-specific virtualization optimizations
# Identifies AMD vs Intel processors to apply appropriate IOMMU and CPU arguments
# Returns: "AMD" or "INTEL" string used throughout script for conditional logic
detect_cpu_platform() {
  lscpu | grep -qi "Vendor ID.*AMD" && echo "AMD" || echo "INTEL"
}

# Comprehensive first-run system configuration that prepares Proxmox host for macOS virtualization
# Executes only once (tracked via marker file) and requires reboot to activate kernel changes
# Configures: locale, package repos, essential tools, GRUB bootloader, kernel modules, and VFIO passthrough
# This function fundamentally alters system boot parameters and driver loading behavior
setup_prerequisites() {
  local logfile="${LOGDIR}/prerequisites-setup.log"
  # Note: OpenCore ISOs are now built on-demand during VM creation
  # No need to copy pre-built ISOs anymore
  # Create convenient shell alias for quick script access
  printf "alias mac='%s/setup'\n" "$SCRIPT_DIR" >> /root/.bashrc
  # Enforce UTF-8 locale to prevent character encoding issues
  printf "LANG=en_US.UTF-8\nLC_ALL=en_US.UTF-8\n" > /etc/environment
  # Disable mouse integration in vim for better terminal compatibility
  printf "set mouse-=a\n" > ~/.vimrc
  # Remove enterprise repository that requires paid subscription
  rm -f /etc/apt/sources.list.d/pve-enterprise.list
  # Update package lists with fallback to main Debian mirror if local mirror fails
  apt-get update >>"$logfile" 2>&1 || {
    local country=$(curl -s https://ipinfo.io/country | tr '[:upper:]' '[:lower:]')
    sed -i "s/ftp.$country.debian.org/ftp.debian.org/g" /etc/apt/sources.list
    apt-get update >>"$logfile" 2>&1 || log_and_exit "Failed to update apt" "$logfile"
  }
  # Install essential utilities for system management, network configuration, and API communication
  apt-get install -y vim unzip zip sysstat parted wget curl iptraf git htop ipcalc coreutils vim-common xmlstarlet >>"$logfile" 2>&1 || log_and_exit "Failed to install packages" "$logfile"
  # Eliminate GRUB boot delay for faster system startup
  sed -i 's/GRUB_TIMEOUT=5/GRUB_TIMEOUT=0/g' /etc/default/grub
  # Configure platform-specific IOMMU and virtualization settings
  local grub_cmd="quiet"
  if [[ $OSX_PLATFORM == "AMD" ]]; then
    # AMD-specific: Enable AMD IOMMU and disable framebuffer conflicts
    grub_cmd="quiet amd_iommu=on iommu=pt video=vesafb:off video=efifb:off"
    printf "options kvm-amd nested=1\n" > /etc/modprobe.d/kvm-amd.conf
  else
    # Intel-specific: Enable Intel VT-d and disable framebuffer conflicts
    grub_cmd="quiet intel_iommu=on iommu=pt video=vesafb:off video=efifb:off"
    printf "options kvm-intel nested=Y\n" > /etc/modprobe.d/kvm-intel.conf
  fi
  # Apply sysfb_init blacklist for specific Proxmox versions to prevent GPU conflicts
  pveversion | grep -qE "pve-manager/(7.[2-4]|8.[0-4]|9)" && grub_cmd="$grub_cmd initcall_blacklist=sysfb_init"
  sed -i "s/GRUB_CMDLINE_LINUX_DEFAULT=\"quiet\"/GRUB_CMDLINE_LINUX_DEFAULT=\"$grub_cmd\"/g" /etc/default/grub
  # Load VFIO kernel modules required for PCI passthrough functionality
  printf "vfio\nvfio_iommu_type1\nvfio_pci\nvfio_virqfd\n" >> /etc/modules
  # Blacklist GPU and audio drivers that interfere with macOS passthrough
  printf "blacklist nouveau\nblacklist nvidia\nblacklist snd_hda_codec_hdmi\nblacklist snd_hda_intel\nblacklist snd_hda_codec\nblacklist snd_hda_core\nblacklist radeon\nblacklist amdgpu\n" >> /etc/modprobe.d/pve-blacklist.conf
  # Suppress KVM MSR warnings that clutter logs during macOS operation
  printf "options kvm ignore_msrs=Y report_ignored_msrs=0\n" > /etc/modprobe.d/kvm.conf
  # Allow VFIO interrupt remapping for better device passthrough compatibility
  printf "options vfio_iommu_type1 allow_unsafe_interrupts=1\n" > /etc/modprobe.d/iommu_unsafe_interrupts.conf
  # Patch Proxmox web UI to remove subscription nag message
  [ -f /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js ] && sed -i.backup -z "s/res === null || res === undefined || \!res || res\n\t\t\t.data.status.toLowerCase() \!== 'active'/false/g" /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js
  # Create marker file to prevent re-running prerequisites on subsequent executions
  touch /etc/pve/qemu-server/.PROXMOX-macOS
  # Regenerate GRUB configuration with new kernel parameters
  update-grub >>"$logfile" 2>&1 || log_and_exit "Failed to update GRUB" "$logfile"
  display_and_log "Prerequisites setup complete. A reboot is necessary to apply the required changes. Press enter to reboot or Ctrl+C if you intend to reboot later." "$logfile"
  read noop
  display_and_log "Enter pressed. Rebooting in 15 seconds..." "$logfile"
  sleep 15 && reboot
}

# macOS recovery image builder for modern macOS (15+)
# Downloads official Apple recovery media and packages into bootable ISO
# Creates FAT32-formatted ISO with BaseSystem.dmg and BaseSystem.chunklist
# Uses macrecovery.py to fetch files via Apple's board/model identifiers
# Skips if recovery image already exists (saves bandwidth and time)
# Parameters: version_name, board_id, model_id, iso_size (e.g., "Sequoia", "Mac-7BA5B2D9E42DDD94", "000...", "1450M")
download_recovery_image() {
  local version_name=$1 board_id=$2 model_id=$3 iso_size=$4
  local logfile="${LOGDIR}/crt-recovery-${version_name,,}.log"
  local iso_path="${ISODIR}/${version_name,,}.iso"

  # Skip creation if recovery image already exists in ISO directory
  [[ -e "$iso_path" ]] && { display_and_log "Recovery image for macOS $version_name already exists" "$logfile"; return; }
  display_and_log "Downloading macOS $version_name recovery image from Apple..." "$logfile"
  # Pre-allocate disk space for ISO file in temporary directory
  fallocate -x -l "$iso_size" "${TMPDIR}/${version_name,,}.iso" >>"$logfile" 2>&1 || log_and_exit "Failed to allocate image" "$logfile"
  # Format as FAT32 filesystem with uppercase volume label
  mkfs.msdos -F 32 "${TMPDIR}/${version_name,,}.iso" -n "${version_name^^}" >>"$logfile" 2>&1 || log_and_exit "Failed to format image" "$logfile"
  # Attach ISO as loop device for mounting
  local loopdev=$(losetup -f --show "${TMPDIR}/${version_name,,}.iso") || log_and_exit "Failed to set up loop device" "$logfile"
  mkdir -p /mnt/APPLE >>"$logfile" 2>&1 || log_and_exit "Failed to create mount point" "$logfile"
  mount "$loopdev" /mnt/APPLE >>"$logfile" 2>&1 || log_and_exit "Failed to mount image" "$logfile"
  cd /mnt/APPLE
  # Construct macrecovery.py arguments with special handling for latest macOS versions
  local recovery_args="-b $board_id -m $model_id download"
  # Modern macOS versions (Sequoia/Tahoe) require the -os latest flag
  [[ "$version_name" =~ ^(Sequoia|Tahoe)$ ]] && recovery_args="$recovery_args -os latest"
  # Download recovery files directly into mounted ISO filesystem
  python3 "${SCRIPT_DIR}/Supporting_Tools/Misc_Tools/macrecovery/macrecovery.py" $recovery_args >>"$logfile" 2>&1 || log_and_exit "Failed to download recovery" "$logfile"
  cd "$SCRIPT_DIR"
  # Clean up mount and loop device
  umount /mnt/APPLE >>"$logfile" 2>&1 || log_and_exit "Failed to unmount image" "$logfile"
  losetup -d "$loopdev" >>"$logfile" 2>&1 || log_and_exit "Failed to detach loop device" "$logfile"
  # Move completed ISO from temp directory to final storage location
  mv "${TMPDIR}/${version_name,,}.iso" "$iso_path" >>"$logfile" 2>&1 || log_and_exit "Failed to move image" "$logfile"
  display_and_log "Recovery image created successfully" "$logfile"
}

# Modern macOS VM creator for Sequoia (15) and Tahoe (26)
# Creates VMs with VirtIO storage/networking, Skylake-Client-v4 CPU, and XHCI USB
# Automatically configures QEMU Guest Agent, disables ballooning, and applies hotplug fixes
# Post-creation: patches config to treat ISOs as disks (required for macOS boot)
# Parameters: version_name, vm_id, vm_name, disk_size, storage, core_count, ram_size, iso_size, disk_type, bridge, custom_iso_name
create_vm() {
  local iso_file version_name=$1 vm_id=$2 vm_name=$3 disk_size=$4 storage=$5 core_count=$6 ram_size=$7 iso_size=$8 disk_type=$9 bridge=${10} custom_iso_name=${11}
  local logfile="${LOGDIR}/crt-vm-${OSX_PLATFORM,,}-${version_name,,}.log"
  
  # Use custom ISO if provided, otherwise use default OpenCore ISO
  if [ -n "$custom_iso_name" ]; then
    iso_file="$custom_iso_name"
    display_and_log "Using custom OpenCore ISO: $iso_file" "$logfile"
  else
    iso_file="${OPENCORE_ISO}"
    # Ensure default OpenCore ISO exists, download if missing
    if [ ! -f "${ISODIR}/$iso_file" ]; then
      update_opencore_iso
    fi
  fi
  # Validate bridge exists in kernel before attempting VM creation
  [[ ! -d "/sys/class/net/$bridge" ]] && log_and_exit "Bridge $bridge does not exist" "$logfile"

  # Build QEMU device arguments starting with Apple SMC emulation (required for macOS boot)
  local cpu_args device_args='-device isa-applesmc,osk="ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc" -smbios type=2'
  # Modern macOS 15+ requires XHCI USB controller
  device_args="$device_args -device qemu-xhci -device usb-kbd -device usb-tablet -global nec-usb-xhci.msi=off"
  
  # CPU emulation per QEMU best practices for macOS
  # Using Skylake-Client-v4 with CPUID model=165 (Comet Lake Mac compatibility)
  # Reference: QEMU CPU optimization for macOS guests
  # This provides ~30-44% better performance than host passthrough
  if [[ "$OSX_PLATFORM" == "AMD" ]]; then
    # AMD: Skylake-Client-v4 with Comet Lake CPUID for Mac compatibility
    cpu_args="-cpu Skylake-Client-v4,vendor=GenuineIntel,model=165,+invtsc,-pcid,-spec-ctrl,kvm=on"
  else
    # Intel: Skylake-Client-v4 with Comet Lake CPUID for optimal performance
    cpu_args="-cpu Skylake-Client-v4,vendor=GenuineIntel,model=165,+invtsc,+kvm_pv_unhalt,+kvm_pv_eoi,kvm=on"
  fi

  # Apply QEMU 6.1+ hotplug workaround to prevent boot hangs
  local qemu_version=$(qemu-system-x86_64 --version | awk '/version/ {print $4}' | cut -d'(' -f1)
  version_compare "$qemu_version" "6.1" && device_args="$device_args -global ICH9-LPC.acpi-pci-hotplug-with-bridge-support=off"

  # Debug: log the actual values being used
  display_and_log "DEBUG: storage_iso='$storage_iso', iso_file='$iso_file'" "$logfile"
  display_and_log "DEBUG: ide0 parameter: ${storage_iso}:iso/${iso_file},media=cdrom,cache=unsafe,size=96M" "$logfile"
  
  # Execute Proxmox qm command with comprehensive VM configuration
  # macOS 15+ uses VirtIO network adapter per NEW-GUIDE.md
  qm create "$vm_id" \
    --agent 1 --args "$device_args $cpu_args" --autostart 0 \
    --balloon 0 --bios ovmf --boot "order=ide0;virtio0" \
    --cores "$core_count" --description "Hackintosh VM - macOS $version_name" \
    --efidisk0 "${storage}:4" --machine q35 --memory "$ram_size" \
    --name "$vm_name" --net0 "virtio,bridge=$bridge" --numa 0 \
    --onboot 0 --ostype other --sockets 1 --start 0 --tablet 1 \
    --vga vmware --vmgenid 1 --scsihw virtio-scsi-pci \
    --virtio0 "${storage}:${disk_size},cache=none,discard=on" \
    --ide0 "${storage_iso}:iso/${iso_file},media=cdrom,cache=unsafe,size=96M" \
    --ide2 "${storage_iso}:iso/${version_name,,}.iso,media=cdrom,cache=unsafe,size=${iso_size}" >>"$logfile" 2>&1 || log_and_exit "Failed to create VM" "$logfile"
  # Critical post-creation patch: Change ISO media type from cdrom to disk (macOS requirement)
  sed -i 's/media=cdrom/media=disk/' "/etc/pve/qemu-server/$vm_id.conf" >>"$logfile" 2>&1 || log_and_exit "Failed to update VM config" "$logfile"

  display_and_log "VM ($vm_name) created successfully" "$logfile"
  
  # Extract bridge IP for displaying web panel access URL
  local bridge_ip=$(ip -4 addr show "$bridge" | awk '/inet/ {print $2}' | cut -d'/' -f1 || echo "unknown")
  
  # Display macOS 26 (Tahoe) cursor freeze fix if applicable
  if [[ "$version_name" == "Tahoe" ]]; then
    display_and_log "\n=== macOS 26 (Tahoe) Cursor Freeze Fix ===" "$logfile"
    display_and_log "To fix cursor freezing issues, run this command in Proxmox shell:" "$logfile"
    display_and_log "  qm set $vm_id -args \"\$(qm config $vm_id --current | grep ^args: | cut -d' ' -f2-) -device virtio-tablet\"" "$logfile"
    display_and_log "Then disable 'Use tablet for pointer' in VM Options tab.\n" "$logfile"
  fi
  
  display_and_log "Access Proxmox Web Panel: https://$bridge_ip:8006" "$logfile"
}

# Proxmox repository configurator that enables free community updates without subscription
# Adds version-specific no-subscription repo (Bullseye for PVE 7, Bookworm for 8, Trixie for 9)
# Proxmox 9 uses new DEB822 format (.sources) instead of traditional one-line format (.list)
# Allows system updates and package installations without enterprise subscription
# Menu option: NVE - Add Proxmox VE no-subscription repo
add_no_subscription_repo() {
  local logfile="${LOGDIR}/add-repo-pve-no-subscription.log"
  # Proxmox VE 7.x uses Debian Bullseye repositories
  if pveversion | grep -q "pve-manager/[7]"; then
    printf "deb http://download.proxmox.com/debian/pve bullseye pve-no-subscription\n" > /etc/apt/sources.list.d/pve-no-sub.list
  # Proxmox VE 8.x uses Debian Bookworm repositories
  elif pveversion | grep -q "pve-manager/[8]"; then
    printf "deb http://download.proxmox.com/debian/pve bookworm pve-no-subscription\n" > /etc/apt/sources.list.d/pve-no-sub.list
  # Proxmox VE 9.x uses Debian Trixie with new DEB822 source format
  elif pveversion | grep -q "pve-manager/[9]"; then
    printf "Types: deb\nURIs: http://download.proxmox.com/debian/pve\nSuites: trixie\nComponents: pve-no-subscription\nSigned-By: /usr/share/keyrings/proxmox-archive-keyring.gpg\n" > /etc/apt/sources.list.d/pve-no-sub.sources
  else
    log_and_exit "Unsupported Proxmox version" "$logfile"
  fi
  # Refresh package index to incorporate new repository
  apt update -y >>"$logfile" 2>&1 || log_and_exit "Failed to update apt" "$logfile"
  display_and_log "Repository added successfully" "$logfile"
  read -n 1 -sp "Press any key to return to menu..."
}

# API-based validated SMBIOS fetcher
# Fetches pre-validated Apple serial numbers from API endpoint
# Returns validated serials that pass Apple's warranty lookup system
# Falls back gracefully to GenSMBIOS if API is unavailable or returns "None"
# Parameters: $1 - Output JSON file path for SMBIOS data
# Returns: 0 on success, 1 on failure (triggers GenSMBIOS fallback)
fetch_validated_smbios() {
  local output_json=$1
  local api_url="https://api.olliebot.ai/webhook/macos-serial-checker-4fcdf009-38eb-49c5-ba28-bfc42178536c"
  local logfile="${LOGDIR}/api-smbios-fetch.log"
  
  echo "→ Fetching validated serial number from API..." >&2
  display_and_log "Fetching validated serial number from API..." "$logfile"
  echo "  URL: $api_url" >&2
  display_and_log "  URL: $api_url" "$logfile"
  
  # Make API POST request with 10 second timeout
  # Try with system CA certificates first, fallback to insecure if needed
  echo "  Attempting connection..." >&2
  display_and_log "  Attempting POST request to API..." "$logfile"
  
  local response
  local curl_exit_code
  
  # First attempt with system CA certificates
  response=$(curl -s -m 10 -X POST --cacert /etc/ssl/certs/ca-certificates.crt "$api_url" 2>&1)
  curl_exit_code=$?
  
  # If that failed, try with -k (insecure)
  if [ $curl_exit_code -ne 0 ]; then
    echo "  First attempt failed (exit code: $curl_exit_code), trying without cert verification..." >&2
    display_and_log "  Certificate verification failed, retrying with -k flag..." "$logfile"
    response=$(curl -s -m 10 -X POST -k "$api_url" 2>&1)
    curl_exit_code=$?
  fi
  
  # Log the curl result
  if [ $curl_exit_code -ne 0 ]; then
    echo "  ERROR: curl failed with exit code $curl_exit_code" >&2
    display_and_log "  curl failed with exit code: $curl_exit_code" "$logfile"
    display_and_log "  Response: $response" "$logfile"
    display_and_log "API request failed. Will use GenSMBIOS instead." "$logfile"
    return 1
  fi
  
  echo "  Connection successful, parsing response..." >&2
  display_and_log "  API responded successfully" "$logfile"
  display_and_log "  Response: $response" "$logfile"
  
  # Check if response is "None" or empty
  if [[ -z "$response" || "$response" == "None" ]]; then
    echo "  API returned no available serials" >&2
    display_and_log "API returned no available serials. Will use GenSMBIOS instead." "$logfile"
    return 1
  fi
  
  # Parse and validate JSON response
  echo "  Parsing JSON response..." >&2
  local api_status=$(echo "$response" | jq -r '.status // empty' 2>>"$logfile")
  local api_type=$(echo "$response" | jq -r '.type // empty' 2>>"$logfile")
  local api_serial=$(echo "$response" | jq -r '.serial // empty' 2>>"$logfile")
  local api_boardserial=$(echo "$response" | jq -r '.boardserial // empty' 2>>"$logfile")
  local api_smuuid=$(echo "$response" | jq -r '.smuuid // empty' 2>>"$logfile")
  local api_applerom=$(echo "$response" | jq -r '.applerom // empty' 2>>"$logfile")
  
  # Note: API returns status:false when serial is available but not actively in use
  # This is actually what we want - an available serial that's not registered
  echo "  API Status: $api_status (false = available for use)" >&2
  
  # Validate all required fields are present
  if [[ -z "$api_type" || -z "$api_serial" || -z "$api_boardserial" || -z "$api_smuuid" || -z "$api_applerom" ]]; then
    echo "  ERROR: API response missing required fields" >&2
    display_and_log "API response missing required fields. Will use GenSMBIOS instead." "$logfile"
    display_and_log "  Response: $response" "$logfile"
    return 1
  fi
  
  # Convert response to GenSMBIOS format and save to JSON file
  echo "  Saving SMBIOS data..." >&2
  jq -n \
    --arg Type "$api_type" \
    --arg Serial "$api_serial" \
    --arg BoardSerial "$api_boardserial" \
    --arg SmUUID "$api_smuuid" \
    --arg ROM "$api_applerom" \
    '{Type: $Type, Serial: $Serial, "Board Serial": $BoardSerial, SmUUID: $SmUUID, ROM: $ROM}' > "$output_json"
  
  echo "  ✓ Success!" >&2
  display_and_log "✓ Validated serial fetched successfully: $api_serial ($api_type)" "$logfile"
  display_and_log "  Board Serial: $api_boardserial" "$logfile"
  display_and_log "  System UUID: $api_smuuid" "$logfile"
  display_and_log "  ROM Address: $api_applerom" "$logfile"
  return 0
}

# SMBIOS injection utility that applies hardware identifiers to OpenCore bootloader ISO
# Mounts ISO, modifies config.plist with serial numbers and board IDs from JSON file
# Generates new SMBIOS if JSON doesn't exist using macserial binary tool
# Automatically adjusts boot-args based on SystemProductName (MacPro5,1 needs special flag)
# Called internally during OpenCore ISO updates to maintain persistent hardware identity
update_opencore_smbios() {
  local iso_path=$1 oc_json_path=$2
  local logfile="${LOGDIR}/update-opencore-smbios.log"
  ensure_xmlstarlet_dependency
  ensure_base64_xxd_dependency "$logfile"
  ensure_jq_dependency

  # Prompt for SMBIOS generation if no existing JSON configuration found
  if [[ ! -f "$oc_json_path" ]]; then
    read -rp "No Serial number generated. Do you want to generate a unique serial number? [Y/n]: " GENSMBIOS
    if [[ "${GENSMBIOS:-Y}" =~ ^[Yy]$ ]]; then
      echo
      echo "╔════════════════════════════════════════════════════════════╗"
      echo "║ SMBIOS Generation Method                                  ║"
      echo "╚════════════════════════════════════════════════════════════╝"
      echo " [A] API - Validated serial (passes Apple warranty lookup)"
      echo " [G] macserial - Random serial generation (offline)"
      echo
      read -rp "Select method [A/g]: " SMBIOS_METHOD
      
      if [[ "${SMBIOS_METHOD:-A}" =~ ^[Aa]$ ]]; then
        # Try API first
        if fetch_validated_smbios "$oc_json_path"; then
          display_and_log "✓ Using validated serial number from API" "$logfile"
        else
          # API failed, fall back to GenSMBIOS
          display_and_log "⚠ API unavailable, falling back to macserial..." "$logfile"
          SystemProductName=$(select_mac_model)
          display_and_log "Selected Mac model: $SystemProductName" "$logfile"
          generate_smbios_with_macserial "$SystemProductName" "$oc_json_path" || log_and_exit "Failed to generate SMBIOS" "$logfile"
        fi
      else
        # User explicitly chose GenSMBIOS
        display_and_log "Using macserial for random serial generation" "$logfile"
        SystemProductName=$(select_mac_model)
        display_and_log "Selected Mac model: $SystemProductName" "$logfile"
        generate_smbios_with_macserial "$SystemProductName" "$oc_json_path" || log_and_exit "Failed to generate SMBIOS" "$logfile"
      fi
    else
      display_and_log "Skipping SMBIOS generation" "$logfile"
      return
    fi
  fi

  # Mount OpenCore ISO with partition support to access EFI filesystem
  local loopdev=$(losetup -f --show -P "$iso_path") || log_and_exit "Failed to set up loop device" "$logfile"
  mkdir -p /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to create mount point" "$logfile"
  mount "${loopdev}p1" /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to mount ISO" "$logfile"
  local config="/mnt/opencore/EFI/OC/config.plist"
  # Create backup before any modifications for rollback capability
  [[ ! -e "$config.backup" ]] && cp "$config" "$config.backup" >>"$logfile" 2>&1

  # Work on temporary copy to enable diff preview before committing changes
  local TEMP_FILE="${config}.tmp"
  cp "$config" "$TEMP_FILE"

  # XPath expressions for navigating OpenCore plist structure
  # NVRAM path targets boot arguments and system configuration variables
  local nvram_xpath="//key[text()='NVRAM']/following-sibling::dict/key[text()='Add']/following-sibling::dict/key[text()='7C436110-AB2A-4BBB-A880-FE41995C9F82']/following-sibling::dict"
  # PlatformInfo path targets SMBIOS hardware identifiers
  local platform_generic_xpath="//key[text()='PlatformInfo']/following-sibling::dict/key[text()='Generic']/following-sibling::dict"

  # Helper function to extract values from plist using XPath queries
  read_plist_value() {
    xmlstarlet sel -t -v "${2}/key[text()='${3}']/following-sibling::*[1]" "$1" 2>/dev/null
  }

  # Helper function to update plist values in-place using XPath
  update_plist_value() {
    xmlstarlet ed -L -u "${2}/key[text()='${3}']/following-sibling::*[1]" -v "$4" "$1"
  }

  # Parse SMBIOS values from JSON file generated by GenSMBIOS tool
  declare -A json_values
  json_values["SystemProductName"]=$(jq -r '.Type // empty' "$oc_json_path")
  json_values["SystemSerialNumber"]=$(jq -r '.Serial // empty' "$oc_json_path")
  json_values["MLB"]=$(jq -r '."Board Serial" // empty' "$oc_json_path")
  json_values["SystemUUID"]=$(jq -r '.SmUUID // empty' "$oc_json_path")
  json_values["ROM"]=$(jq -r '.ROM // empty' "$oc_json_path")  # Stored as hexadecimal string

  # Apply all SMBIOS values from JSON to temporary plist file
  updated=false
  for key in SystemProductName SystemSerialNumber MLB SystemUUID ROM; do
    if [ -n "${json_values[$key]}" ]; then
      # ROM requires special handling: convert hex to base64 for plist storage
      if [ "$key" == "ROM" ]; then
        if command -v base64 >/dev/null 2>&1 && command -v xxd >/dev/null 2>&1; then
          modified_value=$(echo -n "${json_values[$key]}" | xxd -r -p | base64)
        else
          display_and_log "Warning: base64 or xxd not available. Skipping ROM update." "$logfile"
          continue
        fi
      else
        modified_value="${json_values[$key]}"
      fi
      update_plist_value "$TEMP_FILE" "$platform_generic_xpath" "$key" "$modified_value"
      display_and_log "Updated $key from JSON." "$logfile"
      updated=true
    fi
  done

  # Intelligent boot-args management: MacPro5,1 requires Nehalem error suppression
  system_product_name=$(read_plist_value "$TEMP_FILE" "$platform_generic_xpath" "SystemProductName")
  boot_args=$(read_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args")
  flag=" -nehalem_error_disable"

  # Add flag if using MacPro5,1 SMBIOS
  if [ "$system_product_name" = "MacPro5,1" ]; then
    if [[ ! "$boot_args" =~ $flag ]]; then
      new_boot_args="$boot_args$flag"
      update_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args" "$new_boot_args"
      display_and_log "Automatically added '$flag' to boot-args." "$logfile"
      updated=true
    fi
  else
    # Remove flag if not using MacPro5,1 (prevents unnecessary kernel patches)
    if [[ "$boot_args" =~ $flag ]]; then
      new_boot_args="${boot_args//$flag/}"
      update_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args" "$new_boot_args"
      display_and_log "Automatically removed '$flag' from boot-args." "$logfile"
      updated=true
    fi
  fi

  # Present unified diff and request confirmation before applying changes
  if $updated; then
    display_and_log "Differences between original and modified file (unified format):" "$logfile"
    xmlstarlet fo "$config" > "$config.fmt" || log_and_exit "Failed to format original file" "$logfile"
    diff -u "$config.fmt" "$TEMP_FILE" || true
    rm "$config.fmt"

    read -p "Do you want to apply these changes to the original file? (y/n): " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
      mv "$TEMP_FILE" "$config"
      display_and_log "Changes applied to $config" "$logfile"
    else
      display_and_log "Changes discarded." "$logfile"
      rm "$TEMP_FILE"
    fi
  else
    display_and_log "No updates needed from JSON." "$logfile"
    rm "$TEMP_FILE"
  fi

  # Unmount ISO and release loop device resources
  umount /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to unmount ISO" "$logfile"
  losetup -d "$loopdev" >>"$logfile" 2>&1 || log_and_exit "Failed to detach loop device" "$logfile"
}

# Interactive OpenCore configuration editor for advanced customization
# Provides menu-driven interface to modify boot-args, SIP settings, SMBIOS, timeout, and keyboard layout
# Mounts ISO, presents current values, accepts user input, shows diff, and applies changes with confirmation
# Automatically syncs SMBIOS changes back to JSON file for persistence across ISO updates
# Menu option: CCP - Customize OpenCore config.plist
customize_opencore_config() {
  local oc_json_path iso logfile="${LOGDIR}/custom-oc-config.plist.log"
  iso="${ISODIR}/${OPENCORE_ISO}"
  oc_json_path="${ISODIR}/.smbios.json"
  ensure_xmlstarlet_dependency
  ensure_base64_xxd_dependency "$logfile"
  ensure_jq_dependency

  local loopdev=$(losetup -f --show -P "$iso") || log_and_exit "Failed to set up loop device" "$logfile"
  mkdir -p /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to create mount point" "$logfile"
  mount "${loopdev}p1" /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to mount ISO" "$logfile"
  local config="/mnt/opencore/EFI/OC/config.plist"
  [[ ! -e "$config.backup" ]] && cp "$config" "$config.backup" >>"$logfile" 2>&1

  # Temporary file
  local TEMP_FILE="${config}.tmp"
  cp "$config" "$TEMP_FILE"

  # Define base XPaths
  local nvram_xpath="//key[text()='NVRAM']/following-sibling::dict/key[text()='Add']/following-sibling::dict/key[text()='7C436110-AB2A-4BBB-A880-FE41995C9F82']/following-sibling::dict"
  local misc_boot_xpath="//key[text()='Misc']/following-sibling::dict/key[text()='Boot']/following-sibling::dict"
  local platform_generic_xpath="//key[text()='PlatformInfo']/following-sibling::dict/key[text()='Generic']/following-sibling::dict"

  # Define keys and sections
  declare -A key_sections=( ["boot-args"]="nvram" ["csr-active-config"]="nvram" ["prev-lang:kbd"]="nvram" ["Timeout"]="misc_boot" ["MLB"]="platform_generic" ["SystemProductName"]="platform_generic" ["SystemSerialNumber"]="platform_generic" ["SystemUUID"]="platform_generic" ["ROM"]="platform_generic" )
  keys=("boot-args" "csr-active-config" "prev-lang:kbd" "Timeout" "MLB" "SystemProductName" "SystemSerialNumber" "SystemUUID" "ROM")

  # Function to read a value from plist
  read_plist_value() {
    xmlstarlet sel -t -v "${2}/key[text()='${3}']/following-sibling::*[1]" "$1" 2>/dev/null
  }

  # Function to update a value in plist
  update_plist_value() {
    xmlstarlet ed -L -u "${2}/key[text()='${3}']/following-sibling::*[1]" -v "$4" "$1"
  }

  # Function to remove a key from plist
  remove_plist_key() {
    local key_xpath="${2}/key[text()='${3}']"
    local value_xpath="${2}/key[text()='${3}']/following-sibling::*[1]"
    xmlstarlet ed -L -d "$key_xpath" -d "$value_xpath" "$1" || log_and_exit "Failed to remove $3" "$logfile"
  }

  # Integrate JSON logic
  generate_new=false
  if [ -f "$oc_json_path" ]; then
    read -rp "Existing SMBIOS JSON found. Do you want to generate a new serial number? [y/N]: " GENSMBIOS
    if [[ "${GENSMBIOS}" =~ ^[Yy]$ ]]; then
      generate_new=true
    else
      # Apply existing JSON
      declare -A json_values
      json_values["SystemProductName"]=$(jq -r '.Type // empty' "$oc_json_path")
      json_values["SystemSerialNumber"]=$(jq -r '.Serial // empty' "$oc_json_path")
      json_values["MLB"]=$(jq -r '."Board Serial" // empty' "$oc_json_path")
      json_values["SystemUUID"]=$(jq -r '.SmUUID // empty' "$oc_json_path")
      json_values["ROM"]=$(jq -r '.ROM // empty' "$oc_json_path")
      for key in SystemProductName SystemSerialNumber MLB SystemUUID ROM; do
        if [ -n "${json_values[$key]}" ]; then
          if [ "$key" == "ROM" ]; then
            if command -v base64 >/dev/null 2>&1 && command -v xxd >/dev/null 2>&1; then
              modified_value=$(echo -n "${json_values[$key]}" | xxd -r -p | base64)
            else
              display_and_log "Warning: base64 or xxd not available. Skipping ROM update." "$logfile"
              continue
            fi
          else
            modified_value="${json_values[$key]}"
          fi
          update_plist_value "$TEMP_FILE" "$platform_generic_xpath" "$key" "$modified_value"
          display_and_log "Applied $key from existing JSON to temp file." "$logfile"
        fi
      done
    fi
  else
    read -rp "No Serial number generated. Do you want to generate a unique serial number? [Y/n]: " GENSMBIOS
    if [[ "${GENSMBIOS:-Y}" =~ ^[Yy]$ ]]; then
      generate_new=true
    fi
  fi

  # Generate new SMBIOS if requested
  if $generate_new; then
    echo
    echo "╔════════════════════════════════════════════════════════════╗"
    echo "║ SMBIOS Generation Method                                  ║"
    echo "╚════════════════════════════════════════════════════════════╝"
    echo " [A] API - Validated serial (passes Apple warranty lookup)"
    echo " [G] GenSMBIOS - Random serial generation (offline)"
    echo
    read -rp "Select method [A/g]: " SMBIOS_METHOD
    
    if [[ "${SMBIOS_METHOD:-A}" =~ ^[Aa]$ ]]; then
      # Try API first
      if fetch_validated_smbios "$oc_json_path"; then
        display_and_log "✓ Using validated serial number from API" "$logfile"
      else
        # API failed, fall back to macserial
        display_and_log "⚠ API unavailable, falling back to macserial..." "$logfile"
        echo
        SystemProductName="$(read_plist_value "$TEMP_FILE" "$platform_generic_xpath" "SystemProductName")"
        read -e -p "Enter System Product Name (press Enter to keep current): " -i "$SystemProductName" new_value
        if [ -n "$new_value" ] && [ "$new_value" != "$SystemProductName" ]; then
          SystemProductName="$new_value"
        fi
        generate_smbios_with_macserial "$SystemProductName" "$oc_json_path" || log_and_exit "Failed to generate SMBIOS" "$logfile"
      fi
    else
      # User explicitly chose macserial
      display_and_log "Using macserial for random serial generation" "$logfile"
      SystemProductName="$(read_plist_value "$TEMP_FILE" "$platform_generic_xpath" "SystemProductName")"
      read -e -p "Enter System Product Name (press Enter to keep current): " -i "$SystemProductName" new_value
      if [ -n "$new_value" ] && [ "$new_value" != "$SystemProductName" ]; then
        SystemProductName="$new_value"
      fi
      generate_smbios_with_macserial "$SystemProductName" "$oc_json_path" || log_and_exit "Failed to generate SMBIOS" "$logfile"
    fi
    
    # Apply new JSON (regardless of source - API or GenSMBIOS)
    declare -A json_values
    json_values["SystemProductName"]=$(jq -r '.Type // empty' "$oc_json_path")
    json_values["SystemSerialNumber"]=$(jq -r '.Serial // empty' "$oc_json_path")
    json_values["MLB"]=$(jq -r '."Board Serial" // empty' "$oc_json_path")
    json_values["SystemUUID"]=$(jq -r '.SmUUID // empty' "$oc_json_path")
    json_values["ROM"]=$(jq -r '.ROM // empty' "$oc_json_path")
    for key in SystemProductName SystemSerialNumber MLB SystemUUID ROM; do
      if [ -n "${json_values[$key]}" ]; then
        if [ "$key" == "ROM" ]; then
          if command -v base64 >/dev/null 2>&1 && command -v xxd >/dev/null 2>&1; then
            modified_value=$(echo -n "${json_values[$key]}" | xxd -r -p | base64)
          else
            display_and_log "Warning: base64 or xxd not available. Skipping ROM update." "$logfile"
            continue
          fi
        else
          modified_value="${json_values[$key]}"
        fi
        update_plist_value "$TEMP_FILE" "$platform_generic_xpath" "$key" "$modified_value"
        display_and_log "Applied new $key from generated JSON to temp file." "$logfile"
      fi
    done
  fi

  # Prompt for edits
  declare -A modified
  for key in "${keys[@]}"; do
    local section=${key_sections[$key]}
    local base_xpath
    case $section in
      nvram) base_xpath="$nvram_xpath" ;;
      misc_boot) base_xpath="$misc_boot_xpath" ;;
      platform_generic) base_xpath="$platform_generic_xpath" ;;
    esac
    value=$(read_plist_value "$TEMP_FILE" "$base_xpath" "$key")
    if [ -z "$value" ]; then
      display_and_log "Warning: Could not read value for $key" "$logfile"
      continue
    fi

    if [ "$key" == "csr-active-config" ]; then
      current_value="$value"
      echo "Current value for $key: $current_value"
      read -rp "Remove csr-active-config (unlock SIP)? [Y/N] [N]: " RM_CSR_LOCK
      if [[ "${RM_CSR_LOCK:-N}" =~ ^[Yy]$ ]]; then
        modified[$key]="remove"
        display_and_log "SIP unlocked. Use 'csrutil disable' in Recovery OS" "$logfile"
        continue
      fi
      read -e -p "Edit value (press Enter to keep current): " -i "$current_value" new_value
      if [ -n "$new_value" ] && [ "$new_value" != "$current_value" ]; then
        modified[$key]="$new_value"
      fi
    elif [ "$key" == "ROM" ]; then
      rom_convert=false
      if command -v base64 >/dev/null && command -v xxd >/dev/null; then
        rom_convert=true
        current_value=$(echo -n "$value" | base64 -d | xxd -p -c 999 | tr -d '\n' | tr 'a-f' 'A-F')
      else
        current_value="$value"
      fi
      echo "Current value for $key (${rom_convert:+HEX}base64 if not): $current_value"
      read -e -p "Edit value (press Enter to keep current): " -i "$current_value" new_value
      if [ -n "$new_value" ] && [ "$new_value" != "$current_value" ]; then
        if $rom_convert; then
          modified[$key]=$(echo -n "$new_value" | xxd -r -p | base64)
        else
          modified[$key]="$new_value"
        fi
      fi
    else
      current_value="$value"
      echo "Current value for $key: $current_value"
      read -e -p "Edit value (press Enter to keep current): " -i "$current_value" new_value
      if [ -n "$new_value" ] && [ "$new_value" != "$current_value" ]; then
        modified[$key]="$new_value"
      fi
    fi
  done

  # Apply user modifications
  if [ ${#modified[@]} -gt 0 ]; then
    display_and_log "Applying user changes to temporary file..." "$logfile"
    for key in "${!modified[@]}"; do
      local section=${key_sections[$key]}
      local base_xpath
      case $section in
        nvram) base_xpath="$nvram_xpath" ;;
        misc_boot) base_xpath="$misc_boot_xpath" ;;
        platform_generic) base_xpath="$platform_generic_xpath" ;;
      esac
      if [ "${modified[$key]}" == "remove" ]; then
        remove_plist_key "$TEMP_FILE" "$base_xpath" "$key"
      else
        update_plist_value "$TEMP_FILE" "$base_xpath" "$key" "${modified[$key]}"
      fi
    done
  fi

  # Automatic boot-args adjustment
  system_product_name=$(read_plist_value "$TEMP_FILE" "$platform_generic_xpath" "SystemProductName")
  boot_args=$(read_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args")
  flag=" -nehalem_error_disable"

  if [ "$system_product_name" = "MacPro5,1" ]; then
    if [[ ! "$boot_args" =~ $flag ]]; then
      new_boot_args="$boot_args$flag"
      update_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args" "$new_boot_args"
      display_and_log "Automatically added '$flag' to boot-args." "$logfile"
    fi
  else
    if [[ "$boot_args" =~ $flag ]]; then
      new_boot_args="${boot_args//$flag/}"
      update_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args" "$new_boot_args"
      display_and_log "Automatically removed '$flag' from boot-args." "$logfile"
    fi
  fi

  # Show diff if changes
  xmlstarlet fo "$config" > "$config.fmt"
  local diff_output=$(diff -u "$config.fmt" "$TEMP_FILE")
  rm "$config.fmt"
  if [ -n "$diff_output" ]; then
    display_and_log "Differences between original and modified file (unified format):" "$logfile"
    echo "$diff_output"

    read -rp "Do you want to apply these changes to the original file? (y/n): " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
      mv "$TEMP_FILE" "$config"
      display_and_log "Changes applied to $config" "$logfile"

      # Extract and save to JSON
      declare -A extracted
      for key in SystemProductName SystemSerialNumber MLB SystemUUID ROM; do
        val=$(read_plist_value "$config" "$platform_generic_xpath" "$key")
        if [ -z "$val" ]; then
          display_and_log "Warning: Could not read $key from plist." "$logfile"
          continue
        fi
        if [ "$key" == "ROM" ]; then
          if command -v base64 >/dev/null 2>&1 && command -v xxd >/dev/null 2>&1; then
            val=$(echo -n "$val" | base64 -d | xxd -p -c 999 | tr -d '\n' | tr 'a-f' 'A-F')
          else
            display_and_log "Warning: base64 or xxd not available. Skipping ROM extraction." "$logfile"
            continue
          fi
        fi
        extracted[$key]="$val"
      done

      jq -n \
        --arg Type "${extracted[SystemProductName]}" \
        --arg Serial "${extracted[SystemSerialNumber]}" \
        --arg board_serial "${extracted[MLB]}" \
        --arg SmUUID "${extracted[SystemUUID]}" \
        --arg ROM "${extracted[ROM]}" \
        '{Type: $Type, Serial: $Serial, "Board Serial": $board_serial, SmUUID: $SmUUID, ROM: $ROM}' > "$oc_json_path"
      display_and_log "Updated/Created SMBIOS JSON at $oc_json_path" "$logfile"
    else
      display_and_log "Changes discarded." "$logfile"
      rm "$TEMP_FILE"
    fi
  else
    display_and_log "No changes were made." "$logfile"
    rm "$TEMP_FILE"
  fi

  # Cleanup
  umount /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to unmount ISO" "$logfile"
  losetup -d "$loopdev" >>"$logfile" 2>&1 || log_and_exit "Failed to detach loop device" "$logfile"
  display_and_log "OpenCore config customized" "$logfile"
  read -n 1 -sp "Press any key to return to menu..."
}

# Present menu for selecting Mac model for SMBIOS generation
# Returns: Selected Mac model identifier (e.g., "iMac19,1")
# Default: iMac19,1 for maximum compatibility
select_mac_model() {
  echo
  echo "╔════════════════════════════════════════════════════════════╗"
  echo "║ Select Mac Model for SMBIOS Generation                    ║"
  echo "╚════════════════════════════════════════════════════════════╝"
  echo
  echo " 1 - iMac19,1           27-inch iMac (2019)"
  echo " 2 - iMac19,2           21.5-inch iMac (2019)"
  echo " 3 - Macmini8,1         Mac mini (2018)"
  echo " 4 - MacPro7,1          Mac Pro (2019)"
  echo " 5 - MacBookPro15,1     15-inch MacBook Pro (2018-2019)"
  echo " 6 - MacBookPro15,3     15-inch MacBook Pro (2019)"
  echo " 7 - MacBookPro16,1     16-inch MacBook Pro (2019)"
  echo
  echo " Default: iMac19,1 (recommended for best compatibility)"
  echo
  
  local selected_key
  while true; do
    read -rp "Select Mac model [1-7, or ENTER for default]: " selected_key
    
    # Default to option 1 (iMac19,1) if empty
    if [[ -z "$selected_key" ]]; then
      selected_key=1
      break
    fi
    
    # Validate numeric input within range
    if [[ "$selected_key" =~ ^[1-7]$ ]]; then
      break
    else
      echo "Invalid selection. Please enter a number between 1-7."
    fi
  done
  
  # Return the selected model identifier
  case "$selected_key" in
    1) echo "iMac19,1" ;;
    2) echo "iMac19,2" ;;
    3) echo "Macmini8,1" ;;
    4) echo "MacPro7,1" ;;
    5) echo "MacBookPro15,1" ;;
    6) echo "MacBookPro15,3" ;;
    7) echo "MacBookPro16,1" ;;
  esac
}

# Generate SMBIOS using macserial binary directly
# Non-interactive alternative to GenSMBIOS.py menu-driven interface
# Parameters: $1 - Mac model (e.g., "iMac19,1"), $2 - Output JSON path
# Returns: 0 on success, 1 on failure
generate_smbios_with_macserial() {
  local mac_model="$1"
  local output_json="$2"
  local logfile="${LOGDIR}/macserial-generation.log"
  
  echo "→ Generating SMBIOS for $mac_model using macserial..." >&2
  display_and_log "Generating SMBIOS for $mac_model..." "$logfile"
  
  # Locate macserial binary (Linux binary for Proxmox)
  local macserial_bin="${SCRIPT_DIR}/Supporting_Tools/Misc_Tools/macserial/macserial"
  
  if [ ! -f "$macserial_bin" ]; then
    echo "  ERROR: macserial binary not found: $macserial_bin" >&2
    display_and_log "ERROR: macserial binary not found: $macserial_bin" "$logfile"
    return 1
  fi
  
  # Make sure it's executable
  chmod +x "$macserial_bin" 2>/dev/null
  
  # Generate SMBIOS (use -m for model, -n 1 for one result only)
  # NOTE: Do NOT use -a flag as it generates ALL models
  echo "  Calling macserial: -m $mac_model -n 1" >&2
  echo "  Binary: $macserial_bin" >&2
  
  local output
  output=$("$macserial_bin" -m "$mac_model" -n 1 2>&1)
  local macserial_exit=$?
  
  echo "  macserial exit code: $macserial_exit" >&2
  display_and_log "  macserial exit: $macserial_exit" "$logfile"
  
  if [ $macserial_exit -ne 0 ]; then
    echo "  ERROR: macserial failed with exit code $macserial_exit" >&2
    echo "  Output: $output" >&2
    display_and_log "ERROR: macserial generation failed (exit $macserial_exit)" "$logfile"
    display_and_log "  Output: $output" "$logfile"
    return 1
  fi
  
  if [ -z "$output" ]; then
    echo "  ERROR: macserial returned empty output" >&2
    display_and_log "ERROR: macserial returned empty output" "$logfile"
    return 1
  fi
  
  echo "  Raw output:" >&2
  echo "$output" >&2
  display_and_log "  macserial raw output: $output" "$logfile"
  
  echo "  Parsing macserial output..." >&2
  
  # macserial output format is just: "Serial | BoardSerial" (no model name in output)
  # May have warning line about arc4random - skip lines starting with "Warning"
  local data_line=$(echo "$output" | grep -v "^Warning" | grep "|" | head -1)
  
  if [ -z "$data_line" ]; then
    echo "  ERROR: Could not find valid data line with | separator" >&2
    echo "  Full output was: $output" >&2
    display_and_log "ERROR: No valid data line in macserial output" "$logfile"
    return 1
  fi
  
  echo "  Data line: $data_line" >&2
  
  # Parse: "Serial | BoardSerial"
  local serial=$(echo "$data_line" | awk -F'|' '{print $1}' | tr -d ' ')
  local board_serial=$(echo "$data_line" | awk -F'|' '{print $2}' | tr -d ' ')
  
  echo "    Parsed serial: '$serial'" >&2
  echo "    Parsed board serial: '$board_serial'" >&2
  
  if [ -z "$serial" ] || [ -z "$board_serial" ]; then
    echo "  ERROR: Failed to parse serial or board serial from output" >&2
    echo "  Raw output was: '$output'" >&2
    display_and_log "ERROR: Failed to parse macserial output" "$logfile"
    display_and_log "  Output: $output" "$logfile"
    return 1
  fi
  
  # Generate UUID using multiple fallback methods
  local sm_uuid=""
  
  # Try uuidgen first (if available)
  if command -v uuidgen &>/dev/null; then
    sm_uuid=$(uuidgen 2>/dev/null)
  fi
  
  # Fallback 1: Use Linux kernel random UUID
  if [ -z "$sm_uuid" ] && [ -f /proc/sys/kernel/random/uuid ]; then
    sm_uuid=$(cat /proc/sys/kernel/random/uuid 2>/dev/null | tr 'a-z' 'A-Z')
  fi
  
  # Fallback 2: Generate UUID format manually
  if [ -z "$sm_uuid" ]; then
    sm_uuid=$(printf '%08X-%04X-%04X-%04X-%012X' $((RANDOM*32768+RANDOM)) $RANDOM $RANDOM $RANDOM $((RANDOM*32768+RANDOM)))
  fi
  
  echo "    UUID: $sm_uuid" >&2
  
  # Generate ROM (random MAC address format - 12 hex digits)
  local rom=$(printf '%02X%02X%02X%02X%02X%02X' $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256)))
  echo "    ROM: $rom" >&2
  
  # Create JSON file in GenSMBIOS format
  echo "  Creating JSON file at: $output_json" >&2
  jq -n \
    --arg Type "$mac_model" \
    --arg Serial "$serial" \
    --arg BoardSerial "$board_serial" \
    --arg SmUUID "$sm_uuid" \
    --arg ROM "$rom" \
    '{Type: $Type, Serial: $Serial, "Board Serial": $BoardSerial, SmUUID: $SmUUID, ROM: $ROM}' > "$output_json" 2>&1
  
  local jq_exit=$?
  
  if [ $jq_exit -ne 0 ]; then
    echo "  ERROR: jq failed with exit code $jq_exit" >&2
    display_and_log "ERROR: jq command failed ($jq_exit)" "$logfile"
    return 1
  fi
  
  if [ ! -f "$output_json" ]; then
    echo "  ERROR: JSON file was not created" >&2
    display_and_log "ERROR: JSON file was not created at $output_json" "$logfile"
    return 1
  fi
  
  # Verify JSON contents
  echo "  Verifying JSON contents..." >&2
  local json_contents=$(cat "$output_json" 2>&1)
  echo "  JSON: $json_contents" >&2
  display_and_log "  Generated JSON: $json_contents" "$logfile"
  
  # Verify required fields exist in JSON
  local verify_serial=$(jq -r '.Serial // empty' "$output_json" 2>&1)
  if [ -z "$verify_serial" ]; then
    echo "  ERROR: JSON file missing Serial field" >&2
    display_and_log "ERROR: Generated JSON missing Serial field" "$logfile"
    return 1
  fi
  
  echo "  ✓ SMBIOS generated and validated successfully" >&2
  display_and_log "✓ SMBIOS generated successfully: $serial" "$logfile"
  return 0
}

# OpenCore bootloader ISO updater that fetches latest version from GitHub repository
# Downloads fresh ISO, removes old version, and re-applies existing SMBIOS configuration
# Preserves user's serial numbers and hardware identifiers across updates
# Automatically called during VM creation if ISO is missing
# Menu option: OCI - Update OpenCore ISO
update_opencore_iso() {
  local iso_path
  local logfile="${LOGDIR}/update-opencore-iso.log"
  local iso_url="https://github.com/thenotoriousllama/PROXMOX-macOS/raw/main/EFI/opencore-PROXMOX-macOS-vm.iso"
  iso_path="${ISODIR}/${OPENCORE_ISO}"
  oc_json_path="${ISODIR}/.smbios.json"

  # Remove existing ISO to prevent corruption from partial downloads
  rm -f "$iso_path" >>"$logfile" 2>&1
  # Download latest OpenCore ISO from GitHub repository
  if ! wget -q -O "$iso_path" "$iso_url" >>"$logfile" 2>&1; then
    log_and_exit "Failed to download OpenCore ISO" "$logfile"
  fi
  ensure_base64_xxd_dependency
  # Re-inject saved SMBIOS configuration into newly downloaded ISO
  update_opencore_smbios "$iso_path" "$oc_json_path"

  display_and_log "OpenCore ISO updated" "$logfile"
  sleep 5
}

# Build custom OpenCore ISO with SMBIOS and tools
# Orchestrates SMBIOS generation and ISO creation using PROXMOX-EFI base
# Creates custom ISO named OpenCore-{serial}.iso in ISODIR
# Returns the ISO filename for VM creation
build_custom_opencore_iso() {
  local logfile="${LOGDIR}/build-custom-iso.log"
  
  # Redirect display output to stderr so it doesn't get captured by command substitution
  display_and_log "╔═══════════════════════════════════════════════════════════╗" "$logfile" >&2
  display_and_log "║ Custom OpenCore ISO Builder                               ║" "$logfile" >&2
  display_and_log "╚═══════════════════════════════════════════════════════════╝" "$logfile" >&2
  echo >&2
  
  # Step 1: Generate SMBIOS (API with macserial fallback)
  display_and_log "Step 1: Generating SMBIOS values..." "$logfile" >&2
  local smbios_json="${TMPDIR}/.smbios-custom-${RANDOM}.json"
  local mac_model=""
  
  # Try API first
  display_and_log "→ Attempting API SMBIOS generation..." "$logfile" >&2
  if fetch_validated_smbios "$smbios_json"; then
    display_and_log "→ ✓ API SMBIOS generation successful" "$logfile" >&2
  else
    # Fallback to macserial - let user select Mac model
    display_and_log "→ API unavailable, using macserial..." "$logfile" >&2
    mac_model=$(select_mac_model)
    display_and_log "→ Using Mac model: $mac_model" "$logfile" >&2
    
    # Generate SMBIOS using macserial
    if ! generate_smbios_with_macserial "$mac_model" "$smbios_json"; then
      echo "ERROR: macserial generation failed. Check log: $logfile" >&2
      read -n 1 -sp "Press any key to return to menu..."
      exit 1
    fi
  fi
  
  # Extract serial number for ISO naming
  local serial=$(jq -r '.Serial' "$smbios_json" 2>/dev/null)
  if [ -z "$serial" ]; then
    log_and_exit "Failed to extract serial number from SMBIOS JSON" "$logfile"
  fi
  
  display_and_log "→ Serial Number: $serial" "$logfile" >&2
  echo >&2
  
  # Step 2: Build custom ISO using PROXMOX-EFI
  display_and_log "Step 2: Building custom OpenCore ISO..." "$logfile" >&2
  display_and_log "→ Using PROXMOX-EFI base configuration" "$logfile" >&2
  echo >&2
  
  # Call build script - all progress will be visible
  local iso_result_file="${TMPDIR}/.iso-name-$$"
  "${SCRIPT_DIR}/scripts/build-custom-iso.sh" \
    --efi-source "Builder_EFIs/PROXMOX-EFI" \
    --smbios-json "$smbios_json" \
    --output-dir "$ISODIR" \
    --script-dir "$SCRIPT_DIR" \
    --tmpdir "$TMPDIR" \
    --output-name-file "$iso_result_file"
  
  local build_exit=$?
  
  if [ $build_exit -ne 0 ]; then
    echo >&2
    echo "ERROR: Custom ISO build failed with exit code $build_exit" >&2
    echo "Check log file for details: $logfile" >&2
    echo "Also check: ${SCRIPT_DIR}/logs/build-custom-iso.log" >&2
    read -n 1 -sp "Press any key to return to menu..."
    return 1
  fi
  
  # Read ISO name from result file
  local iso_name
  if [ -f "$iso_result_file" ]; then
    iso_name=$(cat "$iso_result_file")
    rm -f "$iso_result_file"
  else
    iso_name="OpenCore-${serial}.iso"
  fi
  
  display_and_log "→ ✓ ISO build complete" "$logfile" >&2
  echo >&2
  display_and_log "╔═══════════════════════════════════════════════════════════╗" "$logfile" >&2
  display_and_log "║ Custom ISO Created Successfully!                         ║" "$logfile" >&2
  display_and_log "╚═══════════════════════════════════════════════════════════╝" "$logfile" >&2
  display_and_log "  ISO Name: $iso_name" "$logfile" >&2
  display_and_log "  Location: $ISODIR" "$logfile" >&2
  display_and_log "  Configuration: PROXMOX-EFI" "$logfile" >&2
  echo >&2
  display_and_log "NOTE: This ISO can be removed after successful macOS installation" "$logfile" >&2
  echo >&2
  
  # Clean up temporary SMBIOS JSON
  rm -f "$smbios_json" 2>/dev/null
  
  # Return ISO filename for VM creation
  echo "$iso_name"
}

# Maintenance utility that removes all downloaded macOS recovery images and their logs
# Frees up disk space by deleting macOS recovery ISO files from ISO storage
# Useful when switching between macOS versions or cleaning up after testing
# Menu option: CRI - Clear all macOS recovery images
clear_recovery_images() {
  find "$ISODIR" -type f \( -name "sequoia.iso" -o -name "tahoe.iso" -o -name "sonoma.iso" -o -name "ventura.iso" \) -delete
  find "$LOGDIR" -type f -name "crt-recovery-*.log" -delete
  display_and_log "All recovery images cleared"
  read -n 1 -sp "Press any key to return to menu..."
}

# Proxmox web UI subscription nag removal tool
# Installs apt hook that automatically patches proxmoxlib.js after package updates
# Prevents subscription warning from reappearing after Proxmox upgrades
# Reinstalls widget toolkit to immediately apply patch without waiting for next update
# Menu option: RPS - Remove Proxmox subscription notice
remove_subscription_notice() {
  echo "DPkg::Post-Invoke { \"if [ -s /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js ] && ! grep -q -F 'NoMoreNagging' /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js; then echo 'Removing subscription nag from UI...'; sed -i '/data\.status/{s/\!//;s/active/NoMoreNagging/}' /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js; fi\" };" >/etc/apt/apt.conf.d/no-nag-script
  apt --reinstall install proxmox-widget-toolkit &>/dev/null
  display_and_log "Subscription notice removed"
  read -n 1 -sp "Press any key to return to menu..."
}

# Comprehensive network bridge provisioning system for isolated macOS VM networks
# Creates NAT-enabled virtual bridges with optional DHCP server configuration
# Implements automatic rollback on failure to prevent network configuration corruption
# Calculates subnet parameters, validates against existing networks, and configures iptables masquerading
# Menu option: NBR - Add new bridge (macOS in cloud)
configure_network_bridge() {
  local logfile="${LOGDIR}/configure-network-bridge.log"

  # Local error handler that logs and terminates function execution
  die() {
    display_and_log "ERROR: $*" "$logfile"
    return 1
  }

  # Local warning handler for non-fatal issues
  warn() {
    display_and_log "WARNING: $*" "$logfile"
  }

  # Local info handler for progress messages
  info() {
    display_and_log "INFO: $*" "$logfile"
  }

  # Network configuration rollback mechanism to prevent system instability
  # Restores /etc/network/interfaces from timestamped backup if bridge activation fails
  restore_backup() {
    local backup_file="$1"
    info "Restoring network configuration from backup..."
    if [[ -f "$backup_file" ]]; then
      if ! cp "$backup_file" "$NETWORK_INTERFACES_FILE"; then
        die "CRITICAL: Failed to restore network configuration from backup! System may be in unstable state."
      fi
      info "Network configuration successfully restored from backup"
      return 0
    else
      die "CRITICAL: Backup file not found! Network configuration may be corrupted."
    fi
  }

  # DHCP server group provisioning for proper daemon permissions
  ensure_dhcp_group() {
    if ! getent group "$DHCP_USER" >/dev/null; then
      info "Creating DHCP server group '$DHCP_USER'..."
      groupadd "$DHCP_USER" || die "Failed to create group '$DHCP_USER'"
    fi
  }

  # Package dependency installer for network utilities and DHCP server
  # Installs ipcalc for subnet calculations and isc-dhcp-server for IP address management
  ensure_dependencies() {
    local deps=("ipcalc")
    local missing=()

    # Check if ISC DHCP server package is installed
    if ! dpkg -l isc-dhcp-server &>/dev/null; then
      deps+=("isc-dhcp-server")
    fi

    for dep in "${deps[@]}"; do
      if ! command -v "$dep" &>/dev/null && ! dpkg -l "$dep" &>/dev/null; then
        missing+=("$dep")
      fi
    done

    if (( ${#missing[@]} > 0 )); then
      info "Installing missing dependencies: ${missing[*]}"
      apt-get update && apt-get install -y "${missing[@]}" >>"$logfile" 2>&1 || die "Failed to install dependencies"
    fi

    # Create DHCP configuration directory with secure permissions
    mkdir -p "$DHCP_CONF_DIR"
    chown root:root "$DHCP_CONF_DIR"
    chmod 755 "$DHCP_CONF_DIR"
  }

  # Subnet parameter calculator using ipcalc to derive network details from CIDR notation
  # Populates global network_info associative array with network, netmask, broadcast, gateway, and DHCP range
  # Reserves first 50 IPs for static assignments, uses remaining addresses for DHCP pool
  calculate_network() {
    local subnet=$1
    declare -gA network_info

    # Validate CIDR format (e.g., 10.27.1.0/24)
    if [[ ! "$subnet" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$ ]]; then
      warn "Invalid subnet format: $subnet"
      return 1
    fi

    # Execute ipcalc to compute network parameters
    if ! ipcalc_output=$(ipcalc -nb "$subnet"); then
      warn "ipcalc failed to process subnet: $subnet"
      return 1
    fi

    # Extract key network values from ipcalc output
    network_info["network"]=$(echo "$ipcalc_output" | awk '/^Network:/ {print $2}' | cut -d'/' -f1)
    network_info["netmask"]=$(echo "$ipcalc_output" | awk '/^Netmask:/ {print $2}')
    network_info["broadcast"]=$(echo "$ipcalc_output" | awk '/^Broadcast:/ {print $2}')
    network_info["hostmin"]=$(echo "$ipcalc_output" | awk '/^HostMin:/ {print $2}')
    network_info["hostmax"]=$(echo "$ipcalc_output" | awk '/^HostMax:/ {print $2}')

    # Reserve .1-.50 for static IPs, use .51-end for DHCP pool
    IFS='.' read -r i1 i2 i3 i4 <<< "${network_info[hostmin]}"
    network_info["range_start"]="$i1.$i2.$i3.$((i4 + 50))"
    network_info["range_end"]="${network_info[hostmax]}"
    # Gateway conventionally uses .1 address
    network_info["gateway"]="${network_info[network]%.*}.1"

    # Verify all required parameters were successfully calculated
    local required=("network" "netmask" "broadcast" "range_start" "range_end" "gateway")
    for key in "${required[@]}"; do
      if [[ -z "${network_info[$key]}" ]]; then
        warn "Failed to calculate network $key for subnet $subnet"
        return 1
      fi
    done
  }

  # Bridge validation
  validate_bridge() {
    local bridge_num=$1
    [[ "$bridge_num" =~ ^[0-9]+$ ]] || { warn "Bridge number must be a positive integer"; return 1; }

    if [[ -d "/sys/class/net/vmbr$bridge_num" || \
          -n $(grep -h "^iface vmbr$bridge_num" "$NETWORK_INTERFACES_FILE" 2>/dev/null) ]]; then
      return 1  # Bridge exists
    fi
    return 0  # Bridge doesn't exist
  }

  # Find next available bridge
  find_next_bridge() {
    local bridge_num=0
    while ! validate_bridge "$bridge_num"; do
      ((bridge_num++))
    done
    echo "$bridge_num"
  }

  # Subnet validation
  validate_subnet() {
    local subnet=$1
    [[ "$subnet" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$ ]] || { warn "Invalid CIDR format"; return 1; }

    IFS='./' read -r ip1 ip2 ip3 ip4 mask <<< "$subnet"
    (( ip1 <= 255 && ip2 <= 255 && ip3 <= 255 && ip4 <= 255 && mask <= 32 )) || { warn "Invalid IP/Netmask"; return 1; }

    # Check for conflicts
    while read -r existing; do
      if [[ -n "$existing" ]]; then
        if ipcalc -n "$subnet" | grep -q "$(ipcalc -n "$existing" | awk -F= '/NETWORK/ {print $2}')"; then
          warn "Subnet conflict detected with $existing"
          return 1
        fi
      fi
    done < <(get_existing_subnets)

    return 0
  }

  get_existing_subnets() {
    grep -h '^iface' "$NETWORK_INTERFACES_FILE" 2>/dev/null | \
    grep -v '^iface lo' | while read -r line; do
      if [[ $line =~ address[[:space:]]+([0-9.]+) ]]; then
        address=${BASH_REMATCH[1]}
        netmask_line=$(grep -A5 "^$line" "$NETWORK_INTERFACES_FILE" 2>/dev/null | grep -m1 'netmask')
        [[ $netmask_line =~ netmask[[:space:]]+([0-9.]+) ]] || continue
        netmask=${BASH_REMATCH[1]}
        cidr=$(ipcalc -p "$address" "$netmask" | awk -F= '/PREFIX/ {print $2}')
        echo "${address}/${cidr}"
      fi
    done
  }

  # Regenerate main dhcpd.conf
  regenerate_dhcpd_conf() {
    # Start with base configuration
    printf "# DHCP Server Configuration\n# Global DHCP options\noption domain-name \"local\";\noption domain-name-servers 8.8.8.8, 8.8.4.4;\n\ndefault-lease-time 604800;\nmax-lease-time 1209600;\n\nauthoritative;\nlog-facility local7;\n" > /etc/dhcp/dhcpd.conf

    # Add includes for all bridge configs
    printf "\n# Bridge configurations\n" >> /etc/dhcp/dhcpd.conf
    for conf in "$DHCP_CONF_DIR"/*.conf; do
      [[ -f "$conf" ]] && printf "include \"%s\";\n" "$conf" >> /etc/dhcp/dhcpd.conf
    done
  }

  # Update DHCP interfaces list
  update_dhcp_interfaces() {
    # Collect all bridge interfaces with DHCP configs
    local interfaces=()
    for conf in "$DHCP_CONF_DIR"/*.conf; do
      [[ -f "$conf" ]] && interfaces+=("$(basename "${conf%.conf}")")
    done

    # Update interfaces list
    printf "INTERFACESv4=\"%s\"\n" "${interfaces[*]}" > /etc/default/isc-dhcp-server
  }

  # DHCP configuration
  configure_dhcp() {
    local bridge_name=$1
    local subnet=$2

    if ! calculate_network "$subnet"; then
      warn "Failed to calculate network parameters for $subnet"
      return 1
    fi

    # Create bridge-specific config
    printf "subnet %s netmask %s {\n" "${network_info[network]}" "${network_info[netmask]}" > "$DHCP_CONF_DIR/$bridge_name.conf"
    printf "    range %s %s;\n" "${network_info[range_start]}" "${network_info[range_end]}" >> "$DHCP_CONF_DIR/$bridge_name.conf"
    printf "    option routers %s;\n" "${network_info[gateway]}" >> "$DHCP_CONF_DIR/$bridge_name.conf"
    printf "    option broadcast-address %s;\n" "${network_info[broadcast]}" >> "$DHCP_CONF_DIR/$bridge_name.conf"
    printf "    option subnet-mask %s;\n" "${network_info[netmask]}" >> "$DHCP_CONF_DIR/$bridge_name.conf"
    printf "    default-lease-time 604800;\n" >> "$DHCP_CONF_DIR/$bridge_name.conf"
    printf "    max-lease-time 1209600;\n" >> "$DHCP_CONF_DIR/$bridge_name.conf"
    printf "}\n" >> "$DHCP_CONF_DIR/$bridge_name.conf"

    # Set permissions
    chown root:root "$DHCP_CONF_DIR/$bridge_name.conf"
    chmod 644 "$DHCP_CONF_DIR/$bridge_name.conf"

    # Regenerate main config
    regenerate_dhcpd_conf

    # Update interfaces list
    update_dhcp_interfaces

    # Validate config
    if ! dhcpd -t -cf /etc/dhcp/dhcpd.conf >>"$logfile" 2>&1; then
      warn "DHCP configuration validation failed"
      return 1
    fi

    # Restart service
    systemctl restart isc-dhcp-server >>"$logfile" 2>&1 || warn "Failed to restart isc-dhcp-server"
    systemctl enable isc-dhcp-server >>"$logfile" 2>&1
  }

  # Network configuration with rollback support
  configure_network() {
    local bridge_num=$1
    local subnet=$2

    info "Calculating network parameters for $subnet..."
    if ! calculate_network "$subnet"; then
      die "Failed to calculate network parameters for $subnet"
    fi

    local gw_iface=$(ip route | awk '/^default/ {print $5}')
    [[ -z "$gw_iface" ]] && die "No default gateway found"

    # Create backup of interfaces file
    local backup_file="${NETWORK_INTERFACES_FILE}.bak-$(date +%Y%m%d-%H%M%S)"
    info "Creating backup of network interfaces: $backup_file"
    cp "$NETWORK_INTERFACES_FILE" "$backup_file" || die "Failed to create backup of $NETWORK_INTERFACES_FILE"

    # Add bridge configuration
    printf "\n" >> "$NETWORK_INTERFACES_FILE"
    printf "auto vmbr%s\n" "$bridge_num" >> "$NETWORK_INTERFACES_FILE"
    printf "iface vmbr%s inet static\n" "$bridge_num" >> "$NETWORK_INTERFACES_FILE"
    printf "\t# Subnet %s using %s for gateway\n" "$subnet" "$gw_iface" >> "$NETWORK_INTERFACES_FILE"
    printf "\taddress %s\n" "${network_info[gateway]}" >> "$NETWORK_INTERFACES_FILE"
    printf "\tnetmask %s\n" "${network_info[netmask]}" >> "$NETWORK_INTERFACES_FILE"
    printf "\tbridge_ports none\n" >> "$NETWORK_INTERFACES_FILE"
    printf "\tbridge_stp off\n" >> "$NETWORK_INTERFACES_FILE"
    printf "\tbridge_fd 0\n" >> "$NETWORK_INTERFACES_FILE"
    printf "\tpost-up echo 1 > /proc/sys/net/ipv4/ip_forward\n" >> "$NETWORK_INTERFACES_FILE"
    printf "\tpost-up iptables -t nat -A POSTROUTING -s '%s' -o %s -j MASQUERADE\n" "$subnet" "$gw_iface" >> "$NETWORK_INTERFACES_FILE"
    printf "\tpost-down iptables -t nat -D POSTROUTING -s '%s' -o %s -j MASQUERADE\n" "$subnet" "$gw_iface" >> "$NETWORK_INTERFACES_FILE"

    # Verify the config was added correctly
    if ! grep -q "iface vmbr$bridge_num inet static" "$NETWORK_INTERFACES_FILE"; then
      warn "Failed to add bridge configuration"
      restore_backup "$backup_file"
      die "Network configuration failed"
    fi

    # Bring up bridge with rollback on failure
    info "Bringing up bridge vmbr$bridge_num..."
    if ! ifup "vmbr$bridge_num" >>"$logfile" 2>&1; then
      warn "Failed to activate bridge"
      restore_backup "$backup_file"
      die "Bridge activation failed - configuration rolled back"
    fi

    # Clean up backup if successful
    rm -f "$backup_file"
  }

  # Prompt with validation
  prompt_with_validation() {
    local prompt=$1
    local default=$2
    local validation_func=$3
    local value

    while true; do
      read -rp "$prompt [$default]: " value
      value=${value:-$default}
      if $validation_func "$value"; then
        echo "$value"
        return
      fi
      display_and_log "Press any key to return to the main menu..."
      read -n 1 -s
      return 1
    done
  }

  # Main execution
  info "Configuring network bridge for macOS in Cloud..."

  # Check root
  (( EUID == 0 )) || die "This function must be run as root"

  ensure_dependencies
  ensure_dhcp_group

  # Get bridge number
  local next_bridge=$(find_next_bridge)
  info "Next available bridge: vmbr$next_bridge"
  local bridge_num
  bridge_num=$(prompt_with_validation "Enter bridge number" "$next_bridge" validate_bridge) || return

  # Get subnet
  local default_subnet="10.27.$bridge_num.0/24"
  local subnet
  subnet=$(prompt_with_validation "Enter subnet for VM bridge in CIDR notation" "$default_subnet" validate_subnet) || return

  # Configure network
  info "Configuring network..."
  configure_network "$bridge_num" "$subnet"

  # Configure DHCP
  read -rp "Configure DHCP server for vmbr$bridge_num? [Y/n]: " answer
  if [[ "${answer,,}" =~ ^(y|)$ ]]; then
    info "Configuring DHCP server..."
    configure_dhcp "vmbr$bridge_num" "$subnet" || {
      warn "DHCP configuration failed. Network bridge configured, but DHCP not enabled."
    }
  fi

  info "Configuration completed:"
  info "Bridge: vmbr$bridge_num"
  info "Subnet: $subnet"
  info "Gateway: ${network_info[gateway]}"
  [[ "${answer,,}" =~ ^(y|)$ ]] && info "DHCP Range: ${network_info[range_start]} - ${network_info[range_end]}"
  info "Network config: $NETWORK_INTERFACES_FILE"
  [[ "${answer,,}" =~ ^(y|)$ ]] && info "DHCP config: $DHCP_CONF_DIR/vmbr$bridge_num.conf"
  display_and_log "Press any key to return to the main menu..."
  read -n 1 -s
}

# Non-interactive VM creation using CLI arguments
create_vm_noninteractive() {
  local logfile="${LOGDIR}/cli-vm-creation.log"
  
  # Validate version
  local macos_option=""
  case "${CLI_VERSION,,}" in
    sequoia) macos_option="1" ;;
    tahoe) macos_option="2" ;;
    *)
      log_and_exit "Invalid macOS version: $CLI_VERSION. Use 'sequoia' or 'tahoe'" "$logfile"
      ;;
  esac
  
  local macopt="${MACOS_CONFIG[$macos_option]}"
  local version_name version board_id model_id iso_size disk_type
  IFS='|' read -r version_name version board_id model_id iso_size disk_type <<< "$macopt"
  
  # Set VM ID (use next available if not specified)
  local vm_id="${CLI_VM_ID:-$(pvesh get /cluster/nextid)}"
  
  # Validate VM ID doesn't exist
  if [[ -e "/etc/pve/qemu-server/$vm_id.conf" ]]; then
    log_and_exit "VM ID $vm_id already exists" "$logfile"
  fi
  
  # Set VM name (use default if not specified)
  local vm_name="${CLI_VM_NAME:-${DEFAULT_VM_PREFIX}$(echo "$version_name" | tr -s ' ' | sed 's/^[ ]*//;s/[ ]*$//;s/[ ]/-/g' | tr '[:lower:]' '[:upper:]' | sed 's/-*$//')}"
  
  if ! validate_vm_name "$vm_name"; then
    log_and_exit "Invalid VM name: $vm_name" "$logfile"
  fi
  
  # Set disk size
  local disk_size="${CLI_DISK_SIZE:-80}"
  
  # Get storage
  local storage="${CLI_STORAGE}"
  if [[ -z "$storage" ]]; then
    local storage_output=$(get_available_storages) || log_and_exit "Failed to retrieve storages" "$logfile"
    local default_storage=$(echo "$storage_output" | tail -1)
    storage="$default_storage"
  fi
  
  # Get bridge
  local bridge="${CLI_BRIDGE:-vmbr0}"
  if [[ ! -d "/sys/class/net/$bridge" ]]; then
    log_and_exit "Bridge $bridge does not exist" "$logfile"
  fi
  
  # Set CPU cores (adjust to power of 2 if needed)
  local cores="${CLI_CORES:-4}"
  if ! is_power_of_2 "$cores"; then
    cores=$(next_power_of_2 "$cores")
    display_and_log "Adjusted cores to power of 2: $cores" "$logfile"
  fi
  ((cores > MAX_CORES)) && cores=$MAX_CORES
  
  # Set RAM (auto-calculate if not specified)
  local ram="${CLI_RAM:-$((BASE_RAM_SIZE + cores * RAM_PER_CORE))}"
  
  # Download recovery image if requested
  if [[ "${CLI_DOWNLOAD_RECOVERY}" == "yes" ]]; then
    download_recovery_image "$version_name" "$board_id" "$model_id" "$iso_size"
  fi
  
  # Create VM
  display_and_log "Creating VM with following configuration:" "$logfile"
  display_and_log "  Version: macOS $version_name ($version)" "$logfile"
  display_and_log "  VM ID: $vm_id" "$logfile"
  display_and_log "  VM Name: $vm_name" "$logfile"
  display_and_log "  Disk: ${disk_size}GB" "$logfile"
  display_and_log "  Storage: $storage" "$logfile"
  display_and_log "  Bridge: $bridge" "$logfile"
  display_and_log "  Cores: $cores" "$logfile"
  display_and_log "  RAM: ${ram}MiB" "$logfile"
  
  create_vm "$version_name" "$vm_id" "$vm_name" "$disk_size" "$storage" "$cores" "$ram" "$iso_size" "$disk_type" "$bridge"
  
  display_and_log "VM created successfully!" "$logfile"
  display_and_log "Start VM: qm start $vm_id" "$logfile"
  display_and_log "View console: Open Proxmox web UI and navigate to VM $vm_id" "$logfile"
}

# Interactive VM configuration wizard for modern macOS (15+)
# Collects: VM ID, name, disk size (default 80GB), storage, bridge, cores, RAM
# All VMs use VirtIO storage/networking, Skylake-Client-v4 CPU, XHCI USB
# Validates inputs and prevents conflicts with existing VMs
# Called from main menu when user selects macOS Sequoia or Tahoe
configure_macos_vm() {
  local macopt=$1
  local nextid=$2
  local version_name version board_id model_id iso_size disk_type opt=$3
  # Parse macOS configuration string from MACOS_CONFIG array
  IFS='|' read -r version_name version board_id model_id iso_size disk_type <<< "$macopt"
  # Generate default VM name from version (e.g., "macOS-SEQUOIA" or "macOS-TAHOE")
  local default_vm_name="${DEFAULT_VM_PREFIX}$(echo "$version_name" | tr -s ' ' | sed 's/^[ ]*//;s/[ ]*$//;s/[ ]/-/g' | tr '[:lower:]' '[:upper:]' | sed 's/-*$//')"
  validate_vm_name "$default_vm_name" || log_and_exit "Invalid default VM name: $default_vm_name" "${LOGDIR}/main-menu.log"
  clear
  display_and_log "══════════════════════════════════════════════════"
  display_and_log "  Configuring macOS $version_name VM"
  display_and_log "══════════════════════════════════════════════════"

  # Prompt for unique VM ID with validation against existing configurations
  while true; do
    read -rp "VM ID [${nextid}]: " VM_ID
    VM_ID=${VM_ID:-$nextid}
    if [[ "$VM_ID" =~ ^[0-9]+$ && ! -e "/etc/pve/qemu-server/$VM_ID.conf" ]]; then
      break
    else
      display_and_log "Invalid or existing VM ID. Please try again."
    fi
  done

  # Prompt for VM name with character validation
  while true; do
    read -rp "VM Name [${default_vm_name}]: " VM_NAME
    VM_NAME=${VM_NAME:-$default_vm_name}
    if validate_vm_name "$VM_NAME"; then
      break
    else
      display_and_log "Invalid VM name. Please use alphanumeric characters, -, _, .; no spaces."
    fi
  done

  echo
  echo "══════════════════════════════════════════════════"
  echo "  Building Custom OpenCore ISO"
  echo "══════════════════════════════════════════════════"
  echo
  
  # Build custom OpenCore ISO with PROXMOX-EFI base
  local CUSTOM_ISO_NAME
  local temp_output="${TMPDIR}/.iso-output-$$"
  
  # Run the builder, show output to user, and capture to file
  build_custom_opencore_iso | tee "$temp_output"
  local build_result=${PIPESTATUS[0]}
  
  # Extract only the ISO filename (last line that ends with .iso)
  if [ $build_result -eq 0 ]; then
    CUSTOM_ISO_NAME=$(grep '\.iso$' "$temp_output" | tail -1)
  fi
  rm -f "$temp_output"
  
  if [ $build_result -ne 0 ] || [ -z "$CUSTOM_ISO_NAME" ]; then
    display_and_log "Failed to build custom ISO. Cannot proceed with VM creation."
    read -n 1 -sp "Press any key to return to menu..."
    return 1
  fi
  
  display_and_log "Custom ISO ready for VM creation: $CUSTOM_ISO_NAME"
  read -n 1 -sp "Press any key to continue with VM configuration..."
  echo
  echo

  # Modern macOS 15+ requires more disk space - default to 80GB
  local default_disk_size=80
  while true; do
    read -rp "Disk size (GB) [default: $default_disk_size]: " SIZEDISK
    SIZEDISK=${SIZEDISK:-$default_disk_size}
    if [[ "$SIZEDISK" =~ ^[0-9]+$ ]]; then
      break
    else
      display_and_log "Disk size must be an integer. Please try again."
    fi
  done

  # Storage Selection
  local storage_output=$(get_available_storages) || { display_and_log "Failed to retrieve storages"; read -n 1 -s; return 1; }
  local storages=() default_storage=""
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    [[ -z "$default_storage" && ! "$line" =~ \| ]] && default_storage="$line" || storages+=("$line")
  done <<< "$storage_output"
  if ((${#storages[@]} == 0)); then
    display_and_log "No storages found"; read -n 1 -s; return 1
  fi
  if ((${#storages[@]} == 1)); then
    STORAGECRTVM="${storages[0]%%|*}"
    display_and_log "Using storage: $STORAGECRTVM"
  else
    while true; do
      display_and_log "Available storages:"
      for s in "${storages[@]}"; do
        storage_name="${s%%|*}"
        avail_space="${s##*|}"
        display_and_log "  - $storage_name ($avail_space GB)"
      done
      read -rp "Storage [${default_storage}]: " STORAGECRTVM
      STORAGECRTVM=${STORAGECRTVM:-$default_storage}
      local valid=false
      for s in "${storages[@]}"; do
        if [[ "$STORAGECRTVM" == "${s%%|*}" ]]; then
          valid=true
          break
        fi
      done
      if $valid; then
        display_and_log "Selected storage: $STORAGECRTVM"
        break
      else
        display_and_log "Invalid storage. Please try again."
      fi
    done
  fi

  # Bridge Selection
  local bridge_output=$(get_available_bridges) || { display_and_log "Failed to retrieve bridges"; read -n 1 -s; return 1; }
  local bridges=() default_bridge=""
  while IFS= read -r line; do
    line=$(echo "$line" | tr -d '\r')
    [[ -z "$line" ]] && continue
    if [[ ! "$line" =~ \| ]]; then
      default_bridge="$line"
    else
      bridges+=("$line")
    fi
  done <<< "$bridge_output"
  if ((${#bridges[@]} == 0)); then
    display_and_log "No bridges found"; read -n 1 -s; return 1
  fi

  declare -A bridge_info
  for b in "${bridges[@]}"; do
    IFS='|' read -r bridge_name ip_addr <<< "$b"
    bridge_info["$bridge_name"]="IP address: ${ip_addr:-unknown}"
  done

  mapfile -t sorted_names < <(printf '%s\n' "${!bridge_info[@]}" | sort -V)

  local default_bridge_num=${default_bridge#vmbr}
  if ((${#bridges[@]} == 1)); then
    name="${sorted_names[0]}"
    ip_info="${bridge_info[$name]}"
    BRIDGECRTVM="$name"
    display_and_log "Using bridge: $BRIDGECRTVM ($ip_info)"
  else
    while true; do
      display_and_log "Available bridges:"
      for name in "${sorted_names[@]}"; do
        bridge_num=${name#vmbr}
        ip_info="${bridge_info[$name]}"
        display_and_log "  - $bridge_num ($name, $ip_info)"
      done
      read -rp "Bridge number [${default_bridge_num}]: " BRIDGE_NUM
      BRIDGE_NUM=${BRIDGE_NUM:-$default_bridge_num}
      if [[ "$BRIDGE_NUM" =~ ^[0-9]+$ ]]; then
        BRIDGECRTVM="vmbr$BRIDGE_NUM"
        if [[ -n "${bridge_info[$BRIDGECRTVM]}" ]]; then
          display_and_log "Selected bridge: $BRIDGECRTVM"
          break
        else
          display_and_log "Invalid bridge number. Please try again."
        fi
      else
        display_and_log "Bridge number must be an integer. Please try again."
      fi
    done
  fi

  # CPU Cores (power of 2 recommended for macOS: 1, 2, 4, 8, 16)
  while true; do
    display_and_log "\nRecommended CPU cores (power of 2): 1, 2, 4, 8, 16"
    read -rp "CPU cores [4]: " PROC_COUNT
    PROC_COUNT=${PROC_COUNT:-4}
    if [[ "$PROC_COUNT" =~ ^[0-9]+$ ]]; then
      if ! is_power_of_2 "$PROC_COUNT"; then
        PROC_COUNT=$(next_power_of_2 "$PROC_COUNT")
        display_and_log "→ Adjusted to next power of 2: $PROC_COUNT"
      fi
      break
    else
      display_and_log "→ CPU cores must be an integer. Please try again."
    fi
  done
  ((PROC_COUNT > MAX_CORES)) && PROC_COUNT=$MAX_CORES

  # RAM (modern macOS 15+ benefits from more RAM)
  while true; do
    default_ram=$((BASE_RAM_SIZE + PROC_COUNT * RAM_PER_CORE))
    display_and_log "\nRecommended RAM: ${default_ram} MiB (minimum 4GB for macOS 15+)"
    read -rp "RAM in MiB [$default_ram]: " RAM_SIZE
    RAM_SIZE=${RAM_SIZE:-$default_ram}
    if [[ "$RAM_SIZE" =~ ^[0-9]+$ ]]; then
      break
    else
      display_and_log "→ RAM must be an integer. Please try again."
    fi
  done

  # Recovery image download (downloads macOS installer from Apple servers)
  echo
  display_and_log "Download macOS recovery image from Apple?"
  display_and_log "(Required for first-time installation, can skip if already downloaded)"
  read -rp "Download recovery image? [Y/n]: " CRTRECODISK
  [[ "${CRTRECODISK:-Y}" =~ ^[Yy]$ ]] && download_recovery_image "$version_name" "$board_id" "$model_id" "$iso_size"
  # Execute VM creation with all collected parameters (including custom ISO)
  create_vm "$version_name" "$VM_ID" "$VM_NAME" "$SIZEDISK" "$STORAGECRTVM" "$PROC_COUNT" "$RAM_SIZE" "$iso_size" "$disk_type" "$BRIDGECRTVM" "$CUSTOM_ISO_NAME"
  
  # Post-creation information about custom ISO
  echo
  display_and_log "╔═══════════════════════════════════════════════════════════╗"
  display_and_log "║ VM Creation Complete                                      ║"
  display_and_log "╚═══════════════════════════════════════════════════════════╝"
  display_and_log "Your VM has been created with a custom OpenCore ISO:"
  display_and_log "  ISO: $CUSTOM_ISO_NAME"
  display_and_log "  Location: $ISODIR"
  echo
  display_and_log "After successful macOS installation and setup, you can:"
  display_and_log "  1. Remove the custom ISO from your VM's CD drive in Proxmox"
  display_and_log "  2. Delete the ISO file to free up space:"
  display_and_log "     rm ${ISODIR}/${CUSTOM_ISO_NAME}"
  echo
  read -n 1 -sp "Press any key to return to menu..."
}

# Primary user interface presenting macOS version selection and maintenance utilities
# Displays banner with version info, dynamically sorted macOS options, and utility commands
# Loops indefinitely until user exits, routing selections to appropriate handler functions
# Queries Proxmox for next available VM ID on each iteration
main_menu() {
  while true; do
    clear
    # Fetch next available VM ID from Proxmox cluster
    NEXTID=$(pvesh get /cluster/nextid)
    echo "═══════════════════════════════════════════════════════════════"
    echo "           H A C K I N T O S H S T E R   -   M O D E R N"
    echo "        macOS 15+ (Sequoia/Tahoe) VM Deployment System"
    echo "═══════════════════════════════════════════════════════════════"
    echo "  by Mario Aldayuz (thenotoriousllama) | https://aldayuz.com"
    echo "  Version: ${HACKOCVERSION} | OpenCore: ${OCVERSION}"
    echo "═══════════════════════════════════════════════════════════════"
    echo
    echo "Next VM ID: ${NEXTID}"
    echo
    echo "╔═══════════════════════════════════════════════════════════╗"
    echo "║ CREATE macOS VM                                           ║"
    echo "╚═══════════════════════════════════════════════════════════╝"
    # Dynamically display macOS versions sorted by version number
    for i in $(for key in "${!MACOS_CONFIG[@]}"; do
      IFS='|' read -r _ version _ _ _ _ <<< "${MACOS_CONFIG[$key]}"
      echo "$version|$key"
    done | sort -t'|' -k1,1V | cut -d'|' -f2); do
      IFS='|' read -r name version _ _ _ _ <<< "${MACOS_CONFIG[$i]}"
      printf " %s - macOS %-10s (Version %s)\n" "$i" "$name" "$version"
    done
    echo
    echo "╔═══════════════════════════════════════════════════════════╗"
    echo "║ SYSTEM UTILITIES                                          ║"
    echo "╚═══════════════════════════════════════════════════════════╝"
    echo " 3 - Add Proxmox VE no-subscription repository"
    echo " 4 - Update default OpenCore ISO (legacy/fallback only)"
    echo " 5 - Clear all cached macOS recovery images"
    echo " 6 - Remove Proxmox subscription notice"
    echo " 7 - Add new network bridge (macOS in cloud)"
    echo " 8 - Customize OpenCore config.plist"
    echo
    echo " 0   - Quit (or press ENTER)"
    echo
    read -rp "Select Option: " OPT
    # Exit on empty input or explicit zero
    [[ -z "$OPT" || "$OPT" -eq 0 ]] && exit

    # Route numeric selections to VM configuration, text selections to utility functions
    if [[ ${MACOS_CONFIG[$OPT]} ]]; then
      configure_macos_vm "${MACOS_CONFIG[$OPT]}" "$NEXTID" "$OPT"
    else
      case $OPT in
        3) add_no_subscription_repo ;;
        4) update_opencore_iso ;;
        5) clear_recovery_images ;;
        6) remove_subscription_notice ;;
        7) configure_network_bridge ;;
        8) customize_opencore_config ;;
        *) echo "Invalid option"; read -n 1 -s ;;
      esac
    fi
  done
}

################################################################################################################################################################################################
# SCRIPT ENTRY POINT - Initialization sequence and main loop
################################################################################################################################################################################################

clear
# Create log and temp directories before any operations
init_dirs
# Verify Proxmox version compatibility (7.x, 8.x, or 9.x)
check_proxmox_version
# Prompt for ISO storage selection and set global ISODIR variable
set_isodir
# Note: OpenCore ISOs are now built on-demand during VM creation
# No need to pre-download default ISO
sleep 2
# Detect CPU platform (AMD vs Intel) for platform-specific configurations
OSX_PLATFORM=$(detect_cpu_platform)
# Check if system has been initialized
if [[ ! -e /etc/pve/qemu-server/.PROXMOX-macOS ]]; then
  echo
  echo "⚠️  System not initialized!"
  echo
  echo "Please run the install script first:"
  echo "  cd /root/PROXMOX-macOS && ./install.sh"
  echo
  echo "This will configure your Proxmox host and reboot the system."
  exit 1
fi
# Enter main menu loop or run non-interactive mode
if [[ "$INTERACTIVE_MODE" == "true" ]]; then
  main_menu
else
  create_vm_noninteractive
fi
