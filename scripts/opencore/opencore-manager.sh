#!/bin/bash
#
# opencore-manager.sh - OpenCore bootloader management for Hackintoshster
# Author: Mario Aldayuz (thenotoriousllama)
# Website: https://aldayuz.com
#
# This script manages OpenCore ISO operations including SMBIOS injection, config customization,
# ISO updates, and custom ISO building.
#

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"

# Source required libraries
source "${SCRIPT_DIR}/scripts/lib/config.sh"
source "${SCRIPT_DIR}/scripts/lib/logging.sh"
source "${SCRIPT_DIR}/scripts/dependencies/dependency-installer.sh"
source "${SCRIPT_DIR}/scripts/smbios/smbios-manager.sh"

# SMBIOS injection utility that applies hardware identifiers to OpenCore bootloader ISO
# Mounts ISO, modifies config.plist with serial numbers and board IDs from JSON file
# Generates new SMBIOS if JSON doesn't exist using macserial binary tool
# Automatically adjusts boot-args based on SystemProductName (MacPro5,1 needs special flag)
# Called internally during OpenCore ISO updates to maintain persistent hardware identity
update_opencore_smbios() {
  local iso_path=$1 oc_json_path=$2
  local logfile="${LOGDIR}/update-opencore-smbios.log"
  ensure_xmlstarlet_dependency
  ensure_base64_xxd_dependency "$logfile"
  ensure_jq_dependency

  # Prompt for SMBIOS generation if no existing JSON configuration found
  if [[ ! -f "$oc_json_path" ]]; then
    read -rp "No Serial number generated. Do you want to generate a unique serial number? [Y/n]: " GENSMBIOS
    if [[ "${GENSMBIOS:-Y}" =~ ^[Yy]$ ]]; then
      echo
      echo "╔════════════════════════════════════════════════════════════╗"
      echo "║ SMBIOS Generation Method                                  ║"
      echo "╚════════════════════════════════════════════════════════════╝"
      echo " [A] API - Validated serial (passes Apple warranty lookup)"
      echo " [G] macserial - Random serial generation (offline)"
      echo
      read -rp "Select method [A/g]: " SMBIOS_METHOD
      
      if [[ "${SMBIOS_METHOD:-A}" =~ ^[Aa]$ ]]; then
        # Try API first
        if fetch_validated_smbios "$oc_json_path"; then
          display_and_log "✓ Using validated serial number from API" "$logfile"
        else
          # API failed, fall back to GenSMBIOS
          display_and_log "⚠ API unavailable, falling back to macserial..." "$logfile"
          SystemProductName=$(select_mac_model)
          display_and_log "Selected Mac model: $SystemProductName" "$logfile"
          generate_smbios_with_macserial "$SystemProductName" "$oc_json_path" || log_and_exit "Failed to generate SMBIOS" "$logfile"
        fi
      else
        # User explicitly chose GenSMBIOS
        display_and_log "Using macserial for random serial generation" "$logfile"
        SystemProductName=$(select_mac_model)
        display_and_log "Selected Mac model: $SystemProductName" "$logfile"
        generate_smbios_with_macserial "$SystemProductName" "$oc_json_path" || log_and_exit "Failed to generate SMBIOS" "$logfile"
      fi
    else
      display_and_log "Skipping SMBIOS generation" "$logfile"
      return
    fi
  fi

  # Mount OpenCore ISO with partition support to access EFI filesystem
  local loopdev=$(losetup -f --show -P "$iso_path") || log_and_exit "Failed to set up loop device" "$logfile"
  mkdir -p /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to create mount point" "$logfile"
  mount "${loopdev}p1" /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to mount ISO" "$logfile"
  local config="/mnt/opencore/EFI/OC/config.plist"
  # Create backup before any modifications for rollback capability
  [[ ! -e "$config.backup" ]] && cp "$config" "$config.backup" >>"$logfile" 2>&1

  # Work on temporary copy to enable diff preview before committing changes
  local TEMP_FILE="${config}.tmp"
  cp "$config" "$TEMP_FILE"

  # XPath expressions for navigating OpenCore plist structure
  # NVRAM path targets boot arguments and system configuration variables
  local nvram_xpath="//key[text()='NVRAM']/following-sibling::dict/key[text()='Add']/following-sibling::dict/key[text()='7C436110-AB2A-4BBB-A880-FE41995C9F82']/following-sibling::dict"
  # PlatformInfo path targets SMBIOS hardware identifiers
  local platform_generic_xpath="//key[text()='PlatformInfo']/following-sibling::dict/key[text()='Generic']/following-sibling::dict"

  # Helper function to extract values from plist using XPath queries
  read_plist_value() {
    xmlstarlet sel -t -v "${2}/key[text()='${3}']/following-sibling::*[1]" "$1" 2>/dev/null
  }

  # Helper function to update plist values in-place using XPath
  update_plist_value() {
    xmlstarlet ed -L -u "${2}/key[text()='${3}']/following-sibling::*[1]" -v "$4" "$1"
  }

  # Parse SMBIOS values from JSON file generated by GenSMBIOS tool
  declare -A json_values
  json_values["SystemProductName"]=$(jq -r '.Type // empty' "$oc_json_path")
  json_values["SystemSerialNumber"]=$(jq -r '.Serial // empty' "$oc_json_path")
  json_values["MLB"]=$(jq -r '."Board Serial" // empty' "$oc_json_path")
  json_values["SystemUUID"]=$(jq -r '.SmUUID // empty' "$oc_json_path")
  json_values["ROM"]=$(jq -r '.ROM // empty' "$oc_json_path")  # Stored as hexadecimal string

  # Apply all SMBIOS values from JSON to temporary plist file
  updated=false
  for key in SystemProductName SystemSerialNumber MLB SystemUUID ROM; do
    if [ -n "${json_values[$key]}" ]; then
      # ROM requires special handling: convert hex to base64 for plist storage
      if [ "$key" == "ROM" ]; then
        if command -v base64 >/dev/null 2>&1 && command -v xxd >/dev/null 2>&1; then
          modified_value=$(echo -n "${json_values[$key]}" | xxd -r -p | base64)
        else
          display_and_log "Warning: base64 or xxd not available. Skipping ROM update." "$logfile"
          continue
        fi
      else
        modified_value="${json_values[$key]}"
      fi
      update_plist_value "$TEMP_FILE" "$platform_generic_xpath" "$key" "$modified_value"
      display_and_log "Updated $key from JSON." "$logfile"
      updated=true
    fi
  done

  # Intelligent boot-args management: MacPro5,1 requires Nehalem error suppression
  system_product_name=$(read_plist_value "$TEMP_FILE" "$platform_generic_xpath" "SystemProductName")
  boot_args=$(read_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args")
  flag=" -nehalem_error_disable"

  # Add flag if using MacPro5,1 SMBIOS
  if [ "$system_product_name" = "MacPro5,1" ]; then
    if [[ ! "$boot_args" =~ $flag ]]; then
      new_boot_args="$boot_args$flag"
      update_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args" "$new_boot_args"
      display_and_log "Automatically added '$flag' to boot-args." "$logfile"
      updated=true
    fi
  else
    # Remove flag if not using MacPro5,1 (prevents unnecessary kernel patches)
    if [[ "$boot_args" =~ $flag ]]; then
      new_boot_args="${boot_args//$flag/}"
      update_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args" "$new_boot_args"
      display_and_log "Automatically removed '$flag' from boot-args." "$logfile"
      updated=true
    fi
  fi

  # Present unified diff and request confirmation before applying changes
  if $updated; then
    display_and_log "Differences between original and modified file (unified format):" "$logfile"
    xmlstarlet fo "$config" > "$config.fmt" || log_and_exit "Failed to format original file" "$logfile"
    diff -u "$config.fmt" "$TEMP_FILE" || true
    rm "$config.fmt"

    read -p "Do you want to apply these changes to the original file? (y/n): " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
      mv "$TEMP_FILE" "$config"
      display_and_log "Changes applied to $config" "$logfile"
    else
      display_and_log "Changes discarded." "$logfile"
      rm "$TEMP_FILE"
    fi
  else
    display_and_log "No updates needed from JSON." "$logfile"
    rm "$TEMP_FILE"
  fi

  # Unmount ISO and release loop device resources
  umount /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to unmount ISO" "$logfile"
  losetup -d "$loopdev" >>"$logfile" 2>&1 || log_and_exit "Failed to detach loop device" "$logfile"
}

# Interactive OpenCore configuration editor for advanced customization
# Provides menu-driven interface to modify boot-args, SIP settings, SMBIOS, timeout, and keyboard layout
# Mounts ISO, presents current values, accepts user input, shows diff, and applies changes with confirmation
# Automatically syncs SMBIOS changes back to JSON file for persistence across ISO updates
# Menu option: CCP - Customize OpenCore config.plist
customize_opencore_config() {
  local oc_json_path iso logfile="${LOGDIR}/custom-oc-config.plist.log"
  iso="${ISODIR}/${OPENCORE_ISO}"
  oc_json_path="${ISODIR}/.smbios.json"
  ensure_xmlstarlet_dependency
  ensure_base64_xxd_dependency "$logfile"
  ensure_jq_dependency

  local loopdev=$(losetup -f --show -P "$iso") || log_and_exit "Failed to set up loop device" "$logfile"
  mkdir -p /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to create mount point" "$logfile"
  mount "${loopdev}p1" /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to mount ISO" "$logfile"
  local config="/mnt/opencore/EFI/OC/config.plist"
  [[ ! -e "$config.backup" ]] && cp "$config" "$config.backup" >>"$logfile" 2>&1

  # Temporary file
  local TEMP_FILE="${config}.tmp"
  cp "$config" "$TEMP_FILE"

  # Define base XPaths
  local nvram_xpath="//key[text()='NVRAM']/following-sibling::dict/key[text()='Add']/following-sibling::dict/key[text()='7C436110-AB2A-4BBB-A880-FE41995C9F82']/following-sibling::dict"
  local misc_boot_xpath="//key[text()='Misc']/following-sibling::dict/key[text()='Boot']/following-sibling::dict"
  local platform_generic_xpath="//key[text()='PlatformInfo']/following-sibling::dict/key[text()='Generic']/following-sibling::dict"

  # Define keys and sections
  declare -A key_sections=( ["boot-args"]="nvram" ["csr-active-config"]="nvram" ["prev-lang:kbd"]="nvram" ["Timeout"]="misc_boot" ["MLB"]="platform_generic" ["SystemProductName"]="platform_generic" ["SystemSerialNumber"]="platform_generic" ["SystemUUID"]="platform_generic" ["ROM"]="platform_generic" )
  keys=("boot-args" "csr-active-config" "prev-lang:kbd" "Timeout" "MLB" "SystemProductName" "SystemSerialNumber" "SystemUUID" "ROM")

  # Function to read a value from plist
  read_plist_value() {
    xmlstarlet sel -t -v "${2}/key[text()='${3}']/following-sibling::*[1]" "$1" 2>/dev/null
  }

  # Function to update a value in plist
  update_plist_value() {
    xmlstarlet ed -L -u "${2}/key[text()='${3}']/following-sibling::*[1]" -v "$4" "$1"
  }

  # Function to remove a key from plist
  remove_plist_key() {
    local key_xpath="${2}/key[text()='${3}']"
    local value_xpath="${2}/key[text()='${3}']/following-sibling::*[1]"
    xmlstarlet ed -L -d "$key_xpath" -d "$value_xpath" "$1" || log_and_exit "Failed to remove $3" "$logfile"
  }

  # Integrate JSON logic
  generate_new=false
  if [ -f "$oc_json_path" ]; then
    read -rp "Existing SMBIOS JSON found. Do you want to generate a new serial number? [y/N]: " GENSMBIOS
    if [[ "${GENSMBIOS}" =~ ^[Yy]$ ]]; then
      generate_new=true
    else
      # Apply existing JSON
      declare -A json_values
      json_values["SystemProductName"]=$(jq -r '.Type // empty' "$oc_json_path")
      json_values["SystemSerialNumber"]=$(jq -r '.Serial // empty' "$oc_json_path")
      json_values["MLB"]=$(jq -r '."Board Serial" // empty' "$oc_json_path")
      json_values["SystemUUID"]=$(jq -r '.SmUUID // empty' "$oc_json_path")
      json_values["ROM"]=$(jq -r '.ROM // empty' "$oc_json_path")
      for key in SystemProductName SystemSerialNumber MLB SystemUUID ROM; do
        if [ -n "${json_values[$key]}" ]; then
          if [ "$key" == "ROM" ]; then
            if command -v base64 >/dev/null 2>&1 && command -v xxd >/dev/null 2>&1; then
              modified_value=$(echo -n "${json_values[$key]}" | xxd -r -p | base64)
            else
              display_and_log "Warning: base64 or xxd not available. Skipping ROM update." "$logfile"
              continue
            fi
          else
            modified_value="${json_values[$key]}"
          fi
          update_plist_value "$TEMP_FILE" "$platform_generic_xpath" "$key" "$modified_value"
          display_and_log "Applied $key from existing JSON to temp file." "$logfile"
        fi
      done
    fi
  else
    read -rp "No Serial number generated. Do you want to generate a unique serial number? [Y/n]: " GENSMBIOS
    if [[ "${GENSMBIOS:-Y}" =~ ^[Yy]$ ]]; then
      generate_new=true
    fi
  fi

  # Generate new SMBIOS if requested
  if $generate_new; then
    echo
    echo "╔════════════════════════════════════════════════════════════╗"
    echo "║ SMBIOS Generation Method                                  ║"
    echo "╚════════════════════════════════════════════════════════════╝"
    echo " [A] API - Validated serial (passes Apple warranty lookup)"
    echo " [G] GenSMBIOS - Random serial generation (offline)"
    echo
    read -rp "Select method [A/g]: " SMBIOS_METHOD
    
    if [[ "${SMBIOS_METHOD:-A}" =~ ^[Aa]$ ]]; then
      # Try API first
      if fetch_validated_smbios "$oc_json_path"; then
        display_and_log "✓ Using validated serial number from API" "$logfile"
      else
        # API failed, fall back to macserial
        display_and_log "⚠ API unavailable, falling back to macserial..." "$logfile"
        echo
        SystemProductName="$(read_plist_value "$TEMP_FILE" "$platform_generic_xpath" "SystemProductName")"
        read -e -p "Enter System Product Name (press Enter to keep current): " -i "$SystemProductName" new_value
        if [ -n "$new_value" ] && [ "$new_value" != "$SystemProductName" ]; then
          SystemProductName="$new_value"
        fi
        generate_smbios_with_macserial "$SystemProductName" "$oc_json_path" || log_and_exit "Failed to generate SMBIOS" "$logfile"
      fi
    else
      # User explicitly chose macserial
      display_and_log "Using macserial for random serial generation" "$logfile"
      SystemProductName="$(read_plist_value "$TEMP_FILE" "$platform_generic_xpath" "SystemProductName")"
      read -e -p "Enter System Product Name (press Enter to keep current): " -i "$SystemProductName" new_value
      if [ -n "$new_value" ] && [ "$new_value" != "$SystemProductName" ]; then
        SystemProductName="$new_value"
      fi
      generate_smbios_with_macserial "$SystemProductName" "$oc_json_path" || log_and_exit "Failed to generate SMBIOS" "$logfile"
    fi
    
    # Apply new JSON (regardless of source - API or GenSMBIOS)
    declare -A json_values
    json_values["SystemProductName"]=$(jq -r '.Type // empty' "$oc_json_path")
    json_values["SystemSerialNumber"]=$(jq -r '.Serial // empty' "$oc_json_path")
    json_values["MLB"]=$(jq -r '."Board Serial" // empty' "$oc_json_path")
    json_values["SystemUUID"]=$(jq -r '.SmUUID // empty' "$oc_json_path")
    json_values["ROM"]=$(jq -r '.ROM // empty' "$oc_json_path")
    for key in SystemProductName SystemSerialNumber MLB SystemUUID ROM; do
      if [ -n "${json_values[$key]}" ]; then
        if [ "$key" == "ROM" ]; then
          if command -v base64 >/dev/null 2>&1 && command -v xxd >/dev/null 2>&1; then
            modified_value=$(echo -n "${json_values[$key]}" | xxd -r -p | base64)
          else
            display_and_log "Warning: base64 or xxd not available. Skipping ROM update." "$logfile"
            continue
          fi
        else
          modified_value="${json_values[$key]}"
        fi
        update_plist_value "$TEMP_FILE" "$platform_generic_xpath" "$key" "$modified_value"
        display_and_log "Applied new $key from generated JSON to temp file." "$logfile"
      fi
    done
  fi

  # Prompt for edits
  declare -A modified
  for key in "${keys[@]}"; do
    local section=${key_sections[$key]}
    local base_xpath
    case $section in
      nvram) base_xpath="$nvram_xpath" ;;
      misc_boot) base_xpath="$misc_boot_xpath" ;;
      platform_generic) base_xpath="$platform_generic_xpath" ;;
    esac
    value=$(read_plist_value "$TEMP_FILE" "$base_xpath" "$key")
    if [ -z "$value" ]; then
      display_and_log "Warning: Could not read value for $key" "$logfile"
      continue
    fi

    if [ "$key" == "csr-active-config" ]; then
      current_value="$value"
      echo "Current value for $key: $current_value"
      read -rp "Remove csr-active-config (unlock SIP)? [Y/N] [N]: " RM_CSR_LOCK
      if [[ "${RM_CSR_LOCK:-N}" =~ ^[Yy]$ ]]; then
        modified[$key]="remove"
        display_and_log "SIP unlocked. Use 'csrutil disable' in Recovery OS" "$logfile"
        continue
      fi
      read -e -p "Edit value (press Enter to keep current): " -i "$current_value" new_value
      if [ -n "$new_value" ] && [ "$new_value" != "$current_value" ]; then
        modified[$key]="$new_value"
      fi
    elif [ "$key" == "ROM" ]; then
      rom_convert=false
      if command -v base64 >/dev/null && command -v xxd >/dev/null; then
        rom_convert=true
        current_value=$(echo -n "$value" | base64 -d | xxd -p -c 999 | tr -d '\n' | tr 'a-f' 'A-F')
      else
        current_value="$value"
      fi
      echo "Current value for $key (${rom_convert:+HEX}base64 if not): $current_value"
      read -e -p "Edit value (press Enter to keep current): " -i "$current_value" new_value
      if [ -n "$new_value" ] && [ "$new_value" != "$current_value" ]; then
        if $rom_convert; then
          modified[$key]=$(echo -n "$new_value" | xxd -r -p | base64)
        else
          modified[$key]="$new_value"
        fi
      fi
    else
      current_value="$value"
      echo "Current value for $key: $current_value"
      read -e -p "Edit value (press Enter to keep current): " -i "$current_value" new_value
      if [ -n "$new_value" ] && [ "$new_value" != "$current_value" ]; then
        modified[$key]="$new_value"
      fi
    fi
  done

  # Apply user modifications
  if [ ${#modified[@]} -gt 0 ]; then
    display_and_log "Applying user changes to temporary file..." "$logfile"
    for key in "${!modified[@]}"; do
      local section=${key_sections[$key]}
      local base_xpath
      case $section in
        nvram) base_xpath="$nvram_xpath" ;;
        misc_boot) base_xpath="$misc_boot_xpath" ;;
        platform_generic) base_xpath="$platform_generic_xpath" ;;
      esac
      if [ "${modified[$key]}" == "remove" ]; then
        remove_plist_key "$TEMP_FILE" "$base_xpath" "$key"
      else
        update_plist_value "$TEMP_FILE" "$base_xpath" "$key" "${modified[$key]}"
      fi
    done
  fi

  # Automatic boot-args adjustment
  system_product_name=$(read_plist_value "$TEMP_FILE" "$platform_generic_xpath" "SystemProductName")
  boot_args=$(read_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args")
  flag=" -nehalem_error_disable"

  if [ "$system_product_name" = "MacPro5,1" ]; then
    if [[ ! "$boot_args" =~ $flag ]]; then
      new_boot_args="$boot_args$flag"
      update_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args" "$new_boot_args"
      display_and_log "Automatically added '$flag' to boot-args." "$logfile"
    fi
  else
    if [[ "$boot_args" =~ $flag ]]; then
      new_boot_args="${boot_args//$flag/}"
      update_plist_value "$TEMP_FILE" "$nvram_xpath" "boot-args" "$new_boot_args"
      display_and_log "Automatically removed '$flag' from boot-args." "$logfile"
    fi
  fi

  # Show diff if changes
  xmlstarlet fo "$config" > "$config.fmt"
  local diff_output=$(diff -u "$config.fmt" "$TEMP_FILE")
  rm "$config.fmt"
  if [ -n "$diff_output" ]; then
    display_and_log "Differences between original and modified file (unified format):" "$logfile"
    echo "$diff_output"

    read -rp "Do you want to apply these changes to the original file? (y/n): " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
      mv "$TEMP_FILE" "$config"
      display_and_log "Changes applied to $config" "$logfile"

      # Extract and save to JSON
      declare -A extracted
      for key in SystemProductName SystemSerialNumber MLB SystemUUID ROM; do
        val=$(read_plist_value "$config" "$platform_generic_xpath" "$key")
        if [ -z "$val" ]; then
          display_and_log "Warning: Could not read $key from plist." "$logfile"
          continue
        fi
        if [ "$key" == "ROM" ]; then
          if command -v base64 >/dev/null 2>&1 && command -v xxd >/dev/null 2>&1; then
            val=$(echo -n "$val" | base64 -d | xxd -p -c 999 | tr -d '\n' | tr 'a-f' 'A-F')
          else
            display_and_log "Warning: base64 or xxd not available. Skipping ROM extraction." "$logfile"
            continue
          fi
        fi
        extracted[$key]="$val"
      done

      jq -n \
        --arg Type "${extracted[SystemProductName]}" \
        --arg Serial "${extracted[SystemSerialNumber]}" \
        --arg board_serial "${extracted[MLB]}" \
        --arg SmUUID "${extracted[SystemUUID]}" \
        --arg ROM "${extracted[ROM]}" \
        '{Type: $Type, Serial: $Serial, "Board Serial": $board_serial, SmUUID: $SmUUID, ROM: $ROM}' > "$oc_json_path"
      display_and_log "Updated/Created SMBIOS JSON at $oc_json_path" "$logfile"
    else
      display_and_log "Changes discarded." "$logfile"
      rm "$TEMP_FILE"
    fi
  else
    display_and_log "No changes were made." "$logfile"
    rm "$TEMP_FILE"
  fi

  # Cleanup
  umount /mnt/opencore >>"$logfile" 2>&1 || log_and_exit "Failed to unmount ISO" "$logfile"
  losetup -d "$loopdev" >>"$logfile" 2>&1 || log_and_exit "Failed to detach loop device" "$logfile"
  display_and_log "OpenCore config customized" "$logfile"
  read -n 1 -sp "Press any key to return to menu..."
}

# OpenCore bootloader ISO updater that fetches latest version from GitHub repository
# Downloads fresh ISO, removes old version, and re-applies existing SMBIOS configuration
# Preserves user's serial numbers and hardware identifiers across updates
# Automatically called during VM creation if ISO is missing
# Menu option: OCI - Update OpenCore ISO
update_opencore_iso() {
  local iso_path
  local logfile="${LOGDIR}/update-opencore-iso.log"
  local iso_url="https://github.com/thenotoriousllama/PROXMOX-macOS/raw/main/EFI/opencore-PROXMOX-macOS-vm.iso"
  iso_path="${ISODIR}/${OPENCORE_ISO}"
  oc_json_path="${ISODIR}/.smbios.json"

  # Remove existing ISO to prevent corruption from partial downloads
  rm -f "$iso_path" >>"$logfile" 2>&1
  # Download latest OpenCore ISO from GitHub repository
  if ! wget -q -O "$iso_path" "$iso_url" >>"$logfile" 2>&1; then
    log_and_exit "Failed to download OpenCore ISO" "$logfile"
  fi
  ensure_base64_xxd_dependency
  # Re-inject saved SMBIOS configuration into newly downloaded ISO
  update_opencore_smbios "$iso_path" "$oc_json_path"

  display_and_log "OpenCore ISO updated" "$logfile"
  sleep 5
}

# Build custom OpenCore ISO with SMBIOS and tools
# Orchestrates SMBIOS generation and ISO creation using PROXMOX-EFI base
# Creates custom ISO named OpenCore-{serial}.iso in ISODIR
# Returns the ISO filename for VM creation
build_custom_opencore_iso() {
  local logfile="${LOGDIR}/build-custom-iso.log"
  
  # Redirect display output to stderr so it doesn't get captured by command substitution
  display_and_log "╔═══════════════════════════════════════════════════════════╗" "$logfile" >&2
  display_and_log "║ Custom OpenCore ISO Builder                               ║" "$logfile" >&2
  display_and_log "╚═══════════════════════════════════════════════════════════╝" "$logfile" >&2
  echo >&2
  
  # Step 1: Generate SMBIOS (API with macserial fallback)
  display_and_log "Step 1: Generating SMBIOS values..." "$logfile" >&2
  local smbios_json="${TMPDIR}/.smbios-custom-${RANDOM}.json"
  local mac_model=""
  
  # Try API first
  display_and_log "→ Attempting API SMBIOS generation..." "$logfile" >&2
  if fetch_validated_smbios "$smbios_json"; then
    display_and_log "→ ✓ API SMBIOS generation successful" "$logfile" >&2
  else
    # Fallback to macserial - let user select Mac model
    display_and_log "→ API unavailable, using macserial..." "$logfile" >&2
    mac_model=$(select_mac_model)
    display_and_log "→ Using Mac model: $mac_model" "$logfile" >&2
    
    # Generate SMBIOS using macserial
    if ! generate_smbios_with_macserial "$mac_model" "$smbios_json"; then
      echo "ERROR: macserial generation failed. Check log: $logfile" >&2
      read -n 1 -sp "Press any key to return to menu..."
      exit 1
    fi
  fi
  
  # Extract serial number for ISO naming
  local serial=$(jq -r '.Serial' "$smbios_json" 2>/dev/null)
  if [ -z "$serial" ]; then
    log_and_exit "Failed to extract serial number from SMBIOS JSON" "$logfile"
  fi
  
  display_and_log "→ Serial Number: $serial" "$logfile" >&2
  echo >&2
  
  # Step 2: Build custom ISO using PROXMOX-EFI
  display_and_log "Step 2: Building custom OpenCore ISO..." "$logfile" >&2
  display_and_log "→ Using PROXMOX-EFI base configuration" "$logfile" >&2
  echo >&2
  
  # Call build script - all progress will be visible
  local iso_result_file="${TMPDIR}/.iso-name-$$"
  "${SCRIPT_DIR}/scripts/build-custom-iso.sh" \
    --efi-source "Builder_EFIs/PROXMOX-EFI" \
    --smbios-json "$smbios_json" \
    --output-dir "$ISODIR" \
    --script-dir "$SCRIPT_DIR" \
    --tmpdir "$TMPDIR" \
    --output-name-file "$iso_result_file"
  
  local build_exit=$?
  
  if [ $build_exit -ne 0 ]; then
    echo >&2
    echo "ERROR: Custom ISO build failed with exit code $build_exit" >&2
    echo "Check log file for details: $logfile" >&2
    echo "Also check: ${SCRIPT_DIR}/logs/build-custom-iso.log" >&2
    read -n 1 -sp "Press any key to return to menu..."
    return 1
  fi
  
  # Read ISO name from result file
  local iso_name
  if [ -f "$iso_result_file" ]; then
    iso_name=$(cat "$iso_result_file")
    rm -f "$iso_result_file"
  else
    iso_name="OpenCore-${serial}.iso"
  fi
  
  display_and_log "→ ✓ ISO build complete" "$logfile" >&2
  echo >&2
  display_and_log "╔═══════════════════════════════════════════════════════════╗" "$logfile" >&2
  display_and_log "║ Custom ISO Created Successfully!                         ║" "$logfile" >&2
  display_and_log "╚═══════════════════════════════════════════════════════════╝" "$logfile" >&2
  display_and_log "  ISO Name: $iso_name" "$logfile" >&2
  display_and_log "  Location: $ISODIR" "$logfile" >&2
  display_and_log "  Configuration: PROXMOX-EFI" "$logfile" >&2
  echo >&2
  display_and_log "NOTE: This ISO can be removed after successful macOS installation" "$logfile" >&2
  echo >&2
  
  # Clean up temporary SMBIOS JSON
  rm -f "$smbios_json" 2>/dev/null
  
  # Return ISO filename for VM creation
  echo "$iso_name"
}

# Export functions for use in other scripts
export -f update_opencore_smbios
export -f customize_opencore_config
export -f update_opencore_iso
export -f build_custom_opencore_iso

